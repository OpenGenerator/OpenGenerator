/**
 * @opengenerator/db-prisma
 *
 * Prisma database adapter for OpenGenerator.
 */

import type {
  DatabasePlugin,
  DatabaseAdapter,
  DatabaseOptions,
  GeneratedCode,
  GeneratedFile,
  SchemaIR,
  Model,
  Dependency,
} from '@opengenerator/core'

export interface PrismaOptions {
  datasource?: 'postgresql' | 'mysql' | 'sqlite' | 'sqlserver' | 'mongodb'
  softDelete?: boolean
  timestamps?: boolean
  connectionString?: string
}

const DEFAULT_OPTIONS: PrismaOptions = {
  datasource: 'postgresql',
  softDelete: false,
  timestamps: true,
}

function generateRepository(model: Model, options: PrismaOptions): string {
  const name = model.name
  const varName = name.charAt(0).toLowerCase() + name.slice(1)

  return `/**
 * ${name} Repository
 * Auto-generated by @opengenerator/db-prisma
 */

import { PrismaClient, ${name} as Prisma${name}, Prisma } from '@prisma/client'

export type ${name} = Prisma${name}
export type ${name}CreateInput = Prisma.${name}CreateInput
export type ${name}UpdateInput = Prisma.${name}UpdateInput
export type ${name}WhereInput = Prisma.${name}WhereInput
export type ${name}OrderByInput = Prisma.${name}OrderByWithRelationInput

export interface FindManyParams {
  filter?: ${name}WhereInput
  pagination?: { page: number; limit: number }
  sort?: { field: string; order: 'asc' | 'desc' }
  include?: Prisma.${name}Include
}

export class ${name}Repository {
  constructor(private prisma: PrismaClient) {}

  async findMany(params: FindManyParams = {}): Promise<{ data: ${name}[]; total: number }> {
    const { filter${options.softDelete ? " = { deletedAt: null }" : ''}, pagination, sort, include } = params

    const where = filter${options.softDelete ? '' : ' || {}'}
    const skip = pagination ? (pagination.page - 1) * pagination.limit : undefined
    const take = pagination?.limit
    const orderBy = sort ? { [sort.field]: sort.order } : undefined

    const [data, total] = await Promise.all([
      this.prisma.${varName}.findMany({ where, skip, take, orderBy, include }),
      this.prisma.${varName}.count({ where }),
    ])

    return { data, total }
  }

  async findById(id: string, include?: Prisma.${name}Include): Promise<${name} | null> {
    return this.prisma.${varName}.findUnique({
      where: { id${options.softDelete ? ", deletedAt: null" : ''} },
      include,
    })
  }

  async findFirst(filter: ${name}WhereInput): Promise<${name} | null> {
    return this.prisma.${varName}.findFirst({
      where: ${options.softDelete ? '{ ...filter, deletedAt: null }' : 'filter'},
    })
  }

  async create(data: ${name}CreateInput): Promise<${name}> {
    return this.prisma.${varName}.create({ data })
  }

  async createMany(data: ${name}CreateInput[]): Promise<{ count: number }> {
    return this.prisma.${varName}.createMany({ data })
  }

  async update(id: string, data: ${name}UpdateInput): Promise<${name}> {
    return this.prisma.${varName}.update({
      where: { id },
      data: {
        ...data,
        ${options.timestamps ? 'updatedAt: new Date(),' : ''}
      },
    })
  }

  async updateMany(filter: ${name}WhereInput, data: ${name}UpdateInput): Promise<{ count: number }> {
    return this.prisma.${varName}.updateMany({
      where: filter,
      data: {
        ...data,
        ${options.timestamps ? 'updatedAt: new Date(),' : ''}
      },
    })
  }

  async delete(id: string): Promise<${name}> {
    ${
      options.softDelete
        ? `return this.prisma.${varName}.update({
      where: { id },
      data: { deletedAt: new Date() },
    })`
        : `return this.prisma.${varName}.delete({ where: { id } })`
    }
  }

  async deleteMany(filter: ${name}WhereInput): Promise<{ count: number }> {
    ${
      options.softDelete
        ? `return this.prisma.${varName}.updateMany({
      where: filter,
      data: { deletedAt: new Date() },
    })`
        : `return this.prisma.${varName}.deleteMany({ where: filter })`
    }
  }

  async count(filter?: ${name}WhereInput): Promise<number> {
    return this.prisma.${varName}.count({
      where: ${options.softDelete ? '{ ...filter, deletedAt: null }' : 'filter'},
    })
  }

  async exists(filter: ${name}WhereInput): Promise<boolean> {
    const count = await this.count(filter)
    return count > 0
  }

  ${
    options.softDelete
      ? `
  async restore(id: string): Promise<${name}> {
    return this.prisma.${varName}.update({
      where: { id },
      data: { deletedAt: null },
    })
  }

  async hardDelete(id: string): Promise<${name}> {
    return this.prisma.${varName}.delete({ where: { id } })
  }
  `
      : ''
  }
}
`
}

function generateClient(schema: SchemaIR, _options: PrismaOptions): string {
  const lines: string[] = [
    '/**',
    ' * Database Client',
    ' * Auto-generated by @opengenerator/db-prisma',
    ' */',
    '',
    "import { PrismaClient } from '@prisma/client'",
  ]

  for (const model of schema.models) {
    lines.push(`import { ${model.name}Repository } from './repositories/${model.name.toLowerCase()}'`)
  }

  lines.push('')
  lines.push('export interface Repositories {')
  for (const model of schema.models) {
    const varName = model.name.charAt(0).toLowerCase() + model.name.slice(1)
    lines.push(`  ${varName}: ${model.name}Repository`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export function createRepositories(prisma: PrismaClient): Repositories {')
  lines.push('  return {')
  for (const model of schema.models) {
    const varName = model.name.charAt(0).toLowerCase() + model.name.slice(1)
    lines.push(`    ${varName}: new ${model.name}Repository(prisma),`)
  }
  lines.push('  }')
  lines.push('}')
  lines.push('')

  lines.push('export function createClient() {')
  lines.push('  const prisma = new PrismaClient()')
  lines.push('  const repositories = createRepositories(prisma)')
  lines.push('  return { prisma, repositories }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function generateIndex(schema: SchemaIR): string {
  const lines: string[] = [
    "export { createClient, createRepositories, type Repositories } from './client'",
  ]

  for (const model of schema.models) {
    lines.push(`export { ${model.name}Repository, type ${model.name}, type ${model.name}CreateInput, type ${model.name}UpdateInput } from './repositories/${model.name.toLowerCase()}'`)
  }

  return lines.join('\n')
}

export function createPrismaDatabase(options: PrismaOptions = {}): DatabasePlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/db-prisma',
    version: '1.0.0',
    adapter: 'prisma' as DatabaseAdapter,

    async generate(schema: SchemaIR, _options: DatabaseOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions, ..._options }
      const files: GeneratedFile[] = []
      const dependencies: Dependency[] = []

      // Generate repositories
      for (const model of schema.models) {
        files.push({
          path: `repositories/${model.name.toLowerCase()}.ts`,
          content: generateRepository(model, opts),
          type: 'source',
        })
      }

      // Generate client
      files.push({ path: 'client.ts', content: generateClient(schema, opts), type: 'source' })
      files.push({ path: 'index.ts', content: generateIndex(schema), type: 'source' })

      dependencies.push(
        { name: '@prisma/client', version: '^5.8.0', dev: false },
        { name: 'prisma', version: '^5.8.0', dev: true }
      )

      return {
        files,
        dependencies,
        metadata: { database: '@opengenerator/db-prisma', version: '1.0.0', options: opts },
      }
    },

    getDependencies(): Dependency[] {
      return [
        { name: '@prisma/client', version: '^5.8.0', dev: false },
        { name: 'prisma', version: '^5.8.0', dev: true }
      ]
    },
  }
}

export const prismaDatabase = createPrismaDatabase()
export default prismaDatabase
