/**
 * @opengenerator/adapter-standalone
 *
 * Standalone HTTP adapter for OpenGenerator.
 * Transforms generated code for Node.js built-in http module with no external dependencies.
 */

import type {
  AdapterPlugin,
  AdapterOptions,
  GeneratedCode,
  GeneratedFile,
  Dependency,
  FrameworkType,
} from '@opengenerator/core'

export interface StandaloneAdapterOptions {
  port?: number
  host?: string
  prefix?: string
  cors?: boolean
}

const DEFAULT_OPTIONS: StandaloneAdapterOptions = {
  port: 3000,
  host: '0.0.0.0',
  prefix: '/api',
  cors: true,
}

/**
 * Generate standalone HTTP server
 */
function generateServer(options: StandaloneAdapterOptions): string {
  const lines: string[] = [
    '/**',
    ' * Standalone HTTP Server',
    ' * Auto-generated by @opengenerator/adapter-standalone',
    ' */',
    '',
    "import { createServer, IncomingMessage, ServerResponse } from 'http'",
    "import { URL } from 'url'",
    '',
    'export interface ServerContext {',
    '  repositories: Record<string, unknown>',
    '}',
    '',
    'interface Route {',
    '  method: string',
    '  pattern: RegExp',
    '  params: string[]',
    '  handler: (req: IncomingMessage, res: ServerResponse, params: Record<string, string>, body: unknown, context: ServerContext) => Promise<void>',
    '}',
    '',
    'async function parseBody(req: IncomingMessage): Promise<unknown> {',
    '  return new Promise((resolve, reject) => {',
    '    const chunks: Buffer[] = []',
    "    req.on('data', chunk => chunks.push(chunk))",
    "    req.on('end', () => {",
    '      const body = Buffer.concat(chunks).toString()',
    '      if (!body) return resolve(undefined)',
    '      try { resolve(JSON.parse(body)) }',
    '      catch { reject(new Error("Invalid JSON")) }',
    '    })',
    "    req.on('error', reject)",
    '  })',
    '}',
    '',
    'function json(res: ServerResponse, data: unknown, status = 200) {',
    '  res.writeHead(status, {',
    "    'Content-Type': 'application/json',",
  ]

  if (options.cors) {
    lines.push("    'Access-Control-Allow-Origin': '*',")
    lines.push("    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',")
    lines.push("    'Access-Control-Allow-Headers': 'Content-Type, Authorization',")
  }

  lines.push('  })')
  lines.push('  res.end(JSON.stringify(data))')
  lines.push('}')
  lines.push('')

  lines.push('function createRoutes(_context: ServerContext): Route[] {')
  lines.push('  return [')
  lines.push('    // Health check route')
  lines.push('    {')
  lines.push("      method: 'GET',")
  lines.push('      pattern: /^\\/health\\/?$/,')
  lines.push('      params: [],')
  lines.push('      handler: async (_req, res) => {')
  lines.push("        json(res, { status: 'ok', timestamp: new Date().toISOString() })")
  lines.push('      },')
  lines.push('    },')
  lines.push('    // Add your routes here')
  lines.push('  ]')
  lines.push('}')
  lines.push('')

  lines.push('export function createApp(context: ServerContext) {')
  lines.push('  const routes = createRoutes(context)')
  lines.push('')
  lines.push('  const server = createServer(async (req, res) => {')

  if (options.cors) {
    lines.push("    if (req.method === 'OPTIONS') {")
    lines.push('      res.writeHead(204, {')
    lines.push("        'Access-Control-Allow-Origin': '*',")
    lines.push("        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',")
    lines.push("        'Access-Control-Allow-Headers': 'Content-Type, Authorization',")
    lines.push('      })')
    lines.push('      res.end()')
    lines.push('      return')
    lines.push('    }')
    lines.push('')
  }

  lines.push('    const url = req.url || "/"')
  lines.push('')
  lines.push('    for (const route of routes) {')
  lines.push('      if (req.method !== route.method) continue')
  lines.push('      const match = url.split("?")[0].match(route.pattern)')
  lines.push('      if (!match) continue')
  lines.push('')
  lines.push('      const params: Record<string, string> = {}')
  lines.push('      route.params.forEach((name, i) => params[name] = match[i + 1])')
  lines.push('')
  lines.push('      try {')
  lines.push('        const body = await parseBody(req)')
  lines.push('        await route.handler(req, res, params, body, context)')
  lines.push('        return')
  lines.push('      } catch (err) {')
  lines.push('        json(res, { error: (err as Error).message }, 500)')
  lines.push('        return')
  lines.push('      }')
  lines.push('    }')
  lines.push('')
  lines.push("    json(res, { error: 'Not Found' }, 404)")
  lines.push('  })')
  lines.push('')
  lines.push('  return {')
  lines.push('    server,')
  lines.push(`    listen: (port = ${options.port}, host = '${options.host}') => {`)
  lines.push('      return new Promise<void>((resolve) => {')
  lines.push('        server.listen(port, host, () => {')
  lines.push('          console.log(`Server running at http://${host}:${port}`)')
  lines.push('          resolve()')
  lines.push('        })')
  lines.push('      })')
  lines.push('    },')
  lines.push('    close: () => new Promise<void>((resolve) => server.close(() => resolve())),')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate index file
 */
function generateIndex(): string {
  return `export { createApp, type ServerContext } from './server'
`
}

/**
 * Create the standalone adapter plugin
 */
export function createStandaloneAdapter(options: StandaloneAdapterOptions = {}): AdapterPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/adapter-standalone',
    version: '1.0.0',
    framework: 'standalone' as FrameworkType,

    async adapt(code: GeneratedCode, _options: AdapterOptions): Promise<GeneratedCode> {
      const files: GeneratedFile[] = [...code.files]

      files.push({
        path: 'server.ts',
        content: generateServer(mergedOptions),
        type: 'source',
      })
      files.push({
        path: 'index.ts',
        content: generateIndex(),
        type: 'source',
      })

      // Standalone has no external dependencies - just merge existing ones
      const dependencies: Dependency[] = [
        ...(code.dependencies || []),
        ...this.getDependencies(),
      ]

      return {
        files,
        dependencies,
        metadata: {
          ...code.metadata,
          adapter: '@opengenerator/adapter-standalone',
          version: '1.0.0',
          options: mergedOptions,
        },
      }
    },

    getDependencies(): Dependency[] {
      // Standalone adapter uses only Node.js built-in modules
      return []
    },
  }
}

export const standaloneAdapter = createStandaloneAdapter()
export default standaloneAdapter
