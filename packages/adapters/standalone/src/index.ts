/**
 * @opengenerator/adapter-standalone
 *
 * Standalone HTTP adapter for OpenGenerator.
 * Transforms generated code for Node.js built-in http module with no external dependencies.
 */

import type {
  AdapterPlugin,
  AdapterOptions,
  GeneratedCode,
  GeneratedFile,
  Dependency,
  FrameworkType,
} from '@opengenerator/core'

export interface StandaloneAdapterOptions {
  port?: number
  host?: string
  prefix?: string
  cors?: boolean
}

const DEFAULT_OPTIONS: StandaloneAdapterOptions = {
  port: 3000,
  host: '0.0.0.0',
  prefix: '/api',
  cors: true,
}

/**
 * Extract route definitions from generated routes.ts file
 */
function extractRoutes(code: GeneratedCode): Array<{ method: string; path: string; handler: string }> {
  const routesFile = code.files.find((f) => f.path === 'routes.ts' || f.path.endsWith('/routes.ts'))
  if (!routesFile) return []

  const routes: Array<{ method: string; path: string; handler: string }> = []
  const routeRegex = /method:\s*['"](\w+)['"]\s*,\s*path:\s*['"]([^'"]+)['"]\s*,\s*handler:\s*['"]([^'"]+)['"]/g

  let match
  while ((match = routeRegex.exec(routesFile.content)) !== null) {
    routes.push({
      method: match[1] ?? '',
      path: match[2] ?? '',
      handler: match[3] ?? '',
    })
  }

  return routes
}

/**
 * Convert path pattern to regex
 */
function pathToRegex(path: string): { pattern: string; params: string[] } {
  const params: string[] = []
  // Escape forward slashes for regex, then replace :param with capture group
  const escaped = path.replace(/\//g, '\\/').replace(/:(\w+)/g, (_match, param) => {
    params.push(param)
    return '([^/]+)'
  })
  return { pattern: `^${escaped}\\/?$`, params }
}

/**
 * Generate standalone HTTP server with integrated routes
 */
function generateServer(
  options: StandaloneAdapterOptions,
  routes: Array<{ method: string; path: string; handler: string }>
): string {
  const lines: string[] = [
    '/**',
    ' * Standalone HTTP Server',
    ' * Auto-generated by @opengenerator/adapter-standalone',
    ' */',
    '',
    "import { createServer, IncomingMessage, ServerResponse } from 'http'",
    '',
    'export interface ServerContext {',
    '  repositories: Record<string, {',
    '    findMany: () => Promise<unknown[]>',
    '    findById: (id: string) => Promise<unknown | undefined>',
    '    create: (data: unknown) => Promise<unknown>',
    '    update: (id: string, data: unknown) => Promise<unknown | null>',
    '    delete: (id: string) => Promise<boolean>',
    '  }>',
    '}',
    '',
    'interface Route {',
    '  method: string',
    '  pattern: RegExp',
    '  params: string[]',
    '  handler: (req: IncomingMessage, res: ServerResponse, params: Record<string, string>, body: unknown, context: ServerContext) => Promise<void>',
    '}',
    '',
    'async function parseBody(req: IncomingMessage): Promise<unknown> {',
    '  return new Promise((resolve, reject) => {',
    '    const chunks: Buffer[] = []',
    "    req.on('data', chunk => chunks.push(chunk))",
    "    req.on('end', () => {",
    '      const body = Buffer.concat(chunks).toString()',
    '      if (!body) return resolve(undefined)',
    '      try { resolve(JSON.parse(body)) }',
    '      catch { reject(new Error("Invalid JSON")) }',
    '    })',
    "    req.on('error', reject)",
    '  })',
    '}',
    '',
    'function parseQuery(url: string): Record<string, string> {',
    '  const query: Record<string, string> = {}',
    '  const qIndex = url.indexOf("?")',
    '  if (qIndex === -1) return query',
    '  const qs = url.slice(qIndex + 1)',
    '  for (const pair of qs.split("&")) {',
    '    const [key, value] = pair.split("=")',
    '    if (key) query[key] = decodeURIComponent(value || "")',
    '  }',
    '  return query',
    '}',
    '',
    'function json(res: ServerResponse, data: unknown, status = 200) {',
    '  res.writeHead(status, {',
    "    'Content-Type': 'application/json',",
  ]

  if (options.cors) {
    lines.push("    'Access-Control-Allow-Origin': '*',")
    lines.push("    'Access-Control-Allow-Methods': 'GET, POST, PUT, PATCH, DELETE, OPTIONS',")
    lines.push("    'Access-Control-Allow-Headers': 'Content-Type, Authorization',")
  }

  lines.push('  })')
  lines.push('  res.end(JSON.stringify(data))')
  lines.push('}')
  lines.push('')

  lines.push('function createRoutes(context: ServerContext): Route[] {')
  lines.push('  return [')
  lines.push('    // Health check route')
  lines.push('    {')
  lines.push("      method: 'GET',")
  lines.push('      pattern: /^\\/health\\/?$/,')
  lines.push('      params: [],')
  lines.push('      handler: async (_req, res) => {')
  lines.push("        json(res, { status: 'ok', timestamp: new Date().toISOString() })")
  lines.push('      },')
  lines.push('    },')

  // Generate actual route handlers from route definitions
  for (const route of routes) {
    const { pattern, params } = pathToRegex(route.path)
    const handlerParts = route.handler.split('.')
    const controllerName = handlerParts[0] ?? ''
    const methodName = handlerParts[1] ?? ''
    // Extract resource name from controller (e.g., 'userController' -> 'user')
    const resourceName = controllerName.replace('Controller', '')

    lines.push('    {')
    lines.push(`      method: '${route.method}',`)
    lines.push(`      pattern: /${pattern}/,`)
    lines.push(`      params: [${params.map((p) => `'${p}'`).join(', ')}],`)
    lines.push('      handler: async (req, res, params, body, ctx) => {')
    lines.push(`        const repo = ctx.repositories['${resourceName}']`)
    lines.push('        if (!repo) {')
    lines.push(`          json(res, { error: 'Repository ${resourceName} not found' }, 500)`)
    lines.push('          return')
    lines.push('        }')

    if (methodName === 'list') {
      lines.push('        try {')
      lines.push('          const query = parseQuery(req.url || "")')
      lines.push('          const data = await repo.findMany()')
      lines.push('          const page = parseInt(query.page || "1", 10)')
      lines.push('          const limit = parseInt(query.limit || "20", 10)')
      lines.push('          const start = (page - 1) * limit')
      lines.push('          const paged = data.slice(start, start + limit)')
      lines.push('          json(res, {')
      lines.push('            data: paged,')
      lines.push(
        '            meta: { total: data.length, page, limit, totalPages: Math.ceil(data.length / limit), hasMore: start + limit < data.length }'
      )
      lines.push('          })')
      lines.push('        } catch (err) {')
      lines.push('          json(res, { error: (err as Error).message }, 500)')
      lines.push('        }')
    } else if (methodName === 'getById') {
      lines.push('        try {')
      lines.push('          const item = await repo.findById(params.id)')
      lines.push('          if (!item) {')
      lines.push(`            json(res, { error: '${resourceName} not found' }, 404)`)
      lines.push('            return')
      lines.push('          }')
      lines.push('          json(res, item)')
      lines.push('        } catch (err) {')
      lines.push('          json(res, { error: (err as Error).message }, 500)')
      lines.push('        }')
    } else if (methodName === 'create') {
      lines.push('        try {')
      lines.push('          const item = await repo.create(body as Record<string, unknown>)')
      lines.push('          json(res, item, 201)')
      lines.push('        } catch (err) {')
      lines.push('          json(res, { error: (err as Error).message }, 400)')
      lines.push('        }')
    } else if (methodName === 'update') {
      lines.push('        try {')
      lines.push('          const existing = await repo.findById(params.id)')
      lines.push('          if (!existing) {')
      lines.push(`            json(res, { error: '${resourceName} not found' }, 404)`)
      lines.push('            return')
      lines.push('          }')
      lines.push('          const item = await repo.update(params.id, body as Record<string, unknown>)')
      lines.push('          json(res, item)')
      lines.push('        } catch (err) {')
      lines.push('          json(res, { error: (err as Error).message }, 400)')
      lines.push('        }')
    } else if (methodName === 'delete') {
      lines.push('        try {')
      lines.push('          const existing = await repo.findById(params.id)')
      lines.push('          if (!existing) {')
      lines.push(`            json(res, { error: '${resourceName} not found' }, 404)`)
      lines.push('            return')
      lines.push('          }')
      lines.push('          await repo.delete(params.id)')
      lines.push('          res.writeHead(204)')
      lines.push('          res.end()')
      lines.push('        } catch (err) {')
      lines.push('          json(res, { error: (err as Error).message }, 500)')
      lines.push('        }')
    }

    lines.push('      },')
    lines.push('    },')
  }

  lines.push('  ]')
  lines.push('}')
  lines.push('')

  lines.push('export function createApp(context: ServerContext) {')
  lines.push('  const routes = createRoutes(context)')
  lines.push('')
  lines.push('  const server = createServer(async (req, res) => {')

  if (options.cors) {
    lines.push("    if (req.method === 'OPTIONS') {")
    lines.push('      res.writeHead(204, {')
    lines.push("        'Access-Control-Allow-Origin': '*',")
    lines.push("        'Access-Control-Allow-Methods': 'GET, POST, PUT, PATCH, DELETE, OPTIONS',")
    lines.push("        'Access-Control-Allow-Headers': 'Content-Type, Authorization',")
    lines.push('      })')
    lines.push('      res.end()')
    lines.push('      return')
    lines.push('    }')
    lines.push('')
  }

  lines.push('    const url = req.url || "/"')
  lines.push('')
  lines.push('    for (const route of routes) {')
  lines.push('      if (req.method !== route.method) continue')
  lines.push('      const match = url.split("?")[0].match(route.pattern)')
  lines.push('      if (!match) continue')
  lines.push('')
  lines.push('      const params: Record<string, string> = {}')
  lines.push('      route.params.forEach((name, i) => params[name] = match[i + 1])')
  lines.push('')
  lines.push('      try {')
  lines.push('        const body = await parseBody(req)')
  lines.push('        await route.handler(req, res, params, body, context)')
  lines.push('        return')
  lines.push('      } catch (err) {')
  lines.push('        json(res, { error: (err as Error).message }, 500)')
  lines.push('        return')
  lines.push('      }')
  lines.push('    }')
  lines.push('')
  lines.push("    json(res, { error: 'Not Found' }, 404)")
  lines.push('  })')
  lines.push('')
  lines.push('  return {')
  lines.push('    server,')
  lines.push(`    listen: (port = ${options.port}, host = '${options.host}') => {`)
  lines.push('      return new Promise<void>((resolve) => {')
  lines.push('        server.listen(port, host, () => {')
  lines.push('          console.log(`Server running at http://${host}:${port}`)')
  lines.push('          resolve()')
  lines.push('        })')
  lines.push('      })')
  lines.push('    },')
  lines.push('    close: () => new Promise<void>((resolve) => server.close(() => resolve())),')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate index file
 */
function generateIndex(): string {
  return `export { createApp, type ServerContext } from './server'
`
}

/**
 * Create the standalone adapter plugin
 */
export function createStandaloneAdapter(options: StandaloneAdapterOptions = {}): AdapterPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/adapter-standalone',
    version: '1.0.0',
    framework: 'standalone' as FrameworkType,

    async adapt(code: GeneratedCode, _options: AdapterOptions): Promise<GeneratedCode> {
      const files: GeneratedFile[] = [...code.files]

      // Extract routes from REST generator output
      const routes = extractRoutes(code)

      files.push({
        path: 'server.ts',
        content: generateServer(mergedOptions, routes),
        type: 'source',
      })
      files.push({
        path: 'index.ts',
        content: generateIndex(),
        type: 'source',
      })

      // Standalone has no external dependencies - just merge existing ones
      const dependencies: Dependency[] = [...(code.dependencies || []), ...this.getDependencies()]

      return {
        files,
        dependencies,
        metadata: {
          ...code.metadata,
          adapter: '@opengenerator/adapter-standalone',
          version: '1.0.0',
          options: mergedOptions,
        },
      }
    },

    getDependencies(): Dependency[] {
      // Standalone adapter uses only Node.js built-in modules
      return []
    },
  }
}

export const standaloneAdapter = createStandaloneAdapter()
export default standaloneAdapter
