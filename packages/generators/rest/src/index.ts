/**
 * @opengenerator/gen-rest
 *
 * REST API generator for OpenGenerator.
 * Generates CRUD endpoints, routes, controllers, and OpenAPI specs.
 */

import type {
  GeneratorPlugin,
  GeneratedCode,
  GeneratedFile,
  GeneratorOptions,
  SchemaIR,
  Field,
  Dependency,
  Model,
} from '@opengenerator/core'
import * as changeCase from 'change-case'

export interface RestGeneratorOptions {
  /**
   * API prefix (e.g., '/api/v1')
   */
  prefix?: string

  /**
   * Generate OpenAPI specification
   */
  openapi?: boolean

  /**
   * OpenAPI version
   */
  openapiVersion?: '3.0' | '3.1'

  /**
   * Include pagination
   */
  pagination?: boolean

  /**
   * Include filtering
   */
  filtering?: boolean

  /**
   * Include sorting
   */
  sorting?: boolean

  /**
   * Include soft delete
   */
  softDelete?: boolean

  /**
   * Generate validation schemas
   */
  validation?: boolean

  /**
   * HTTP methods to generate
   */
  methods?: Array<'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'>

  /**
   * Custom route patterns
   */
  routePatterns?: {
    list?: string // GET /resources
    create?: string // POST /resources
    get?: string // GET /resources/:id
    update?: string // PUT /resources/:id
    patch?: string // PATCH /resources/:id
    delete?: string // DELETE /resources/:id
  }

  /**
   * Generate bulk operations
   */
  bulkOperations?: boolean

  /**
   * Generate nested routes for relations
   */
  nestedRoutes?: boolean

  /**
   * Response format
   */
  responseFormat?: 'json-api' | 'simple' | 'hal'
}

const DEFAULT_OPTIONS: RestGeneratorOptions = {
  prefix: '/api/v1',
  openapi: true,
  openapiVersion: '3.0',
  pagination: true,
  filtering: true,
  sorting: true,
  softDelete: false,
  validation: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
  bulkOperations: false,
  nestedRoutes: true,
  responseFormat: 'simple',
}

/**
 * Get the scalar type name from a field
 */
function getFieldTypeName(field: Field): string {
  if (field.type.kind === 'scalar') {
    return field.type.type
  }
  return 'string'
}

/**
 * Generate TypeScript type for a field
 */
function fieldToTsType(field: Field): string {
  const typeMap: Record<string, string> = {
    string: 'string',
    int: 'number',
    float: 'number',
    boolean: 'boolean',
    datetime: 'Date',
    json: 'Record<string, unknown>',
    bigint: 'bigint',
    decimal: 'string',
    bytes: 'Buffer',
  }

  const typeName = getFieldTypeName(field)
  let tsType = typeMap[typeName] || 'unknown'

  if (field.type.kind === 'array') {
    tsType = `${tsType}[]`
  }

  if (!field.required) {
    tsType = `${tsType} | null`
  }

  return tsType
}

/**
 * Generate types file
 */
function generateTypes(schema: SchemaIR): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated REST API types',
    ' * DO NOT EDIT - Generated by @opengenerator/gen-rest',
    ' */',
    '',
  ]

  for (const model of schema.models) {
    const modelName = model.name

    // Main type
    lines.push(`export interface ${modelName} {`)
    for (const field of model.fields) {
      const optional = !field.required ? '?' : ''
      lines.push(`  ${field.name}${optional}: ${fieldToTsType(field)}`)
    }
    lines.push('}')
    lines.push('')

    // Create input type
    lines.push(`export interface ${modelName}CreateInput {`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue
      const optional = !field.required || field.default !== undefined ? '?' : ''
      lines.push(`  ${field.name}${optional}: ${fieldToTsType(field)}`)
    }
    lines.push('}')
    lines.push('')

    // Update input type
    lines.push(`export interface ${modelName}UpdateInput {`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue
      lines.push(`  ${field.name}?: ${fieldToTsType(field)}`)
    }
    lines.push('}')
    lines.push('')

    // Filter type
    lines.push(`export interface ${modelName}Filter {`)
    for (const field of model.fields) {
      const typeName = getFieldTypeName(field)
      if (typeName === 'json') continue
      lines.push(`  ${field.name}?: ${fieldToTsType(field)}`)
      if (typeName === 'string') {
        lines.push(`  ${field.name}_contains?: string`)
        lines.push(`  ${field.name}_startsWith?: string`)
        lines.push(`  ${field.name}_endsWith?: string`)
      }
      if (['int', 'float', 'datetime', 'bigint', 'decimal'].includes(typeName)) {
        lines.push(`  ${field.name}_gt?: ${fieldToTsType(field)}`)
        lines.push(`  ${field.name}_gte?: ${fieldToTsType(field)}`)
        lines.push(`  ${field.name}_lt?: ${fieldToTsType(field)}`)
        lines.push(`  ${field.name}_lte?: ${fieldToTsType(field)}`)
      }
    }
    lines.push('}')
    lines.push('')
  }

  // Pagination types
  lines.push('export interface PaginationParams {')
  lines.push('  page?: number')
  lines.push('  limit?: number')
  lines.push('  cursor?: string')
  lines.push('}')
  lines.push('')

  lines.push('export interface PaginatedResponse<T> {')
  lines.push('  data: T[]')
  lines.push('  meta: {')
  lines.push('    total: number')
  lines.push('    page: number')
  lines.push('    limit: number')
  lines.push('    totalPages: number')
  lines.push('    hasMore: boolean')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  // Sort type
  lines.push('export interface SortParams {')
  lines.push('  field: string')
  lines.push("  order: 'asc' | 'desc'")
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate controller for a model
 */
function generateController(model: Model, options: RestGeneratorOptions): string {
  const modelName = model.name

  const lines: string[] = [
    '/**',
    ` * ${modelName} Controller`,
    ' * Auto-generated by @opengenerator/gen-rest',
    ' */',
    '',
    `import type { ${modelName}, ${modelName}CreateInput, ${modelName}UpdateInput, ${modelName}Filter, PaginatedResponse } from './types'`,
    '',
    `export interface ${modelName}Repository {`,
    `  findMany(params: { filter?: ${modelName}Filter; pagination?: { page: number; limit: number }; sort?: { field: string; order: 'asc' | 'desc' } }): Promise<{ data: ${modelName}[]; total: number }>`,
    `  findById(id: string): Promise<${modelName} | null>`,
    `  create(data: ${modelName}CreateInput): Promise<${modelName}>`,
    `  update(id: string, data: ${modelName}UpdateInput): Promise<${modelName}>`,
    `  delete(id: string): Promise<void>`,
    '}',
    '',
    `export class ${modelName}Controller {`,
    `  constructor(private repository: ${modelName}Repository) {}`,
    '',
  ]

  // List method
  if (options.methods?.includes('GET')) {
    lines.push(`  async list(params: {`)
    lines.push(`    filter?: ${modelName}Filter`)
    if (options.pagination) {
      lines.push(`    page?: number`)
      lines.push(`    limit?: number`)
    }
    if (options.sorting) {
      lines.push(`    sortBy?: string`)
      lines.push(`    sortOrder?: 'asc' | 'desc'`)
    }
    lines.push(`  }): Promise<PaginatedResponse<${modelName}>> {`)
    lines.push(`    const { filter, page = 1, limit = 20, sortBy, sortOrder = 'asc' } = params`)
    lines.push('')
    lines.push('    const { data, total } = await this.repository.findMany({')
    lines.push('      filter,')
    lines.push('      pagination: { page, limit },')
    lines.push("      sort: sortBy ? { field: sortBy, order: sortOrder } : undefined,")
    lines.push('    })')
    lines.push('')
    lines.push('    const totalPages = Math.ceil(total / limit)')
    lines.push('')
    lines.push('    return {')
    lines.push('      data,')
    lines.push('      meta: {')
    lines.push('        total,')
    lines.push('        page,')
    lines.push('        limit,')
    lines.push('        totalPages,')
    lines.push('        hasMore: page < totalPages,')
    lines.push('      },')
    lines.push('    }')
    lines.push('  }')
    lines.push('')

    // Get by ID
    lines.push(`  async getById(id: string): Promise<${modelName}> {`)
    lines.push('    const item = await this.repository.findById(id)')
    lines.push('    if (!item) {')
    lines.push(`      throw new Error('${modelName} not found')`)
    lines.push('    }')
    lines.push('    return item')
    lines.push('  }')
    lines.push('')
  }

  // Create method
  if (options.methods?.includes('POST')) {
    lines.push(`  async create(data: ${modelName}CreateInput): Promise<${modelName}> {`)
    lines.push('    return this.repository.create(data)')
    lines.push('  }')
    lines.push('')
  }

  // Update method
  if (options.methods?.includes('PUT') || options.methods?.includes('PATCH')) {
    lines.push(`  async update(id: string, data: ${modelName}UpdateInput): Promise<${modelName}> {`)
    lines.push('    await this.getById(id) // Verify exists')
    lines.push('    return this.repository.update(id, data)')
    lines.push('  }')
    lines.push('')
  }

  // Delete method
  if (options.methods?.includes('DELETE')) {
    lines.push('  async delete(id: string): Promise<void> {')
    lines.push('    await this.getById(id) // Verify exists')
    lines.push('    await this.repository.delete(id)')
    lines.push('  }')
    lines.push('')
  }

  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate routes file
 */
function generateRoutes(schema: SchemaIR, options: RestGeneratorOptions): string {
  const prefix = options.prefix || '/api/v1'

  const lines: string[] = [
    '/**',
    ' * REST API Routes',
    ' * Auto-generated by @opengenerator/gen-rest',
    ' */',
    '',
    'export interface RouteDefinition {',
    '  method: string',
    '  path: string',
    '  handler: string',
    '  middleware?: string[]',
    '}',
    '',
    'export const routes: RouteDefinition[] = [',
  ]

  for (const model of schema.models) {
    const modelName = model.name
    const routeName = changeCase.kebabCase(modelName)
    const controllerName = `${changeCase.camelCase(modelName)}Controller`

    // List
    if (options.methods?.includes('GET')) {
      lines.push(`  {`)
      lines.push(`    method: 'GET',`)
      lines.push(`    path: '${prefix}/${routeName}',`)
      lines.push(`    handler: '${controllerName}.list',`)
      lines.push(`  },`)

      // Get by ID
      lines.push(`  {`)
      lines.push(`    method: 'GET',`)
      lines.push(`    path: '${prefix}/${routeName}/:id',`)
      lines.push(`    handler: '${controllerName}.getById',`)
      lines.push(`  },`)
    }

    // Create
    if (options.methods?.includes('POST')) {
      lines.push(`  {`)
      lines.push(`    method: 'POST',`)
      lines.push(`    path: '${prefix}/${routeName}',`)
      lines.push(`    handler: '${controllerName}.create',`)
      lines.push(`  },`)
    }

    // Update (PUT)
    if (options.methods?.includes('PUT')) {
      lines.push(`  {`)
      lines.push(`    method: 'PUT',`)
      lines.push(`    path: '${prefix}/${routeName}/:id',`)
      lines.push(`    handler: '${controllerName}.update',`)
      lines.push(`  },`)
    }

    // Partial update (PATCH)
    if (options.methods?.includes('PATCH')) {
      lines.push(`  {`)
      lines.push(`    method: 'PATCH',`)
      lines.push(`    path: '${prefix}/${routeName}/:id',`)
      lines.push(`    handler: '${controllerName}.update',`)
      lines.push(`  },`)
    }

    // Delete
    if (options.methods?.includes('DELETE')) {
      lines.push(`  {`)
      lines.push(`    method: 'DELETE',`)
      lines.push(`    path: '${prefix}/${routeName}/:id',`)
      lines.push(`    handler: '${controllerName}.delete',`)
      lines.push(`  },`)
    }
  }

  lines.push(']')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate OpenAPI specification
 */
function generateOpenAPI(schema: SchemaIR, options: RestGeneratorOptions): string {
  const prefix = options.prefix || '/api/v1'

  const spec: Record<string, unknown> = {
    openapi: options.openapiVersion === '3.1' ? '3.1.0' : '3.0.3',
    info: {
      title: 'Generated API',
      version: '1.0.0',
      description: 'Auto-generated REST API by OpenGenerator',
    },
    servers: [
      {
        url: 'http://localhost:3000',
        description: 'Development server',
      },
    ],
    paths: {} as Record<string, unknown>,
    components: {
      schemas: {} as Record<string, unknown>,
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
  }

  const paths = spec.paths as Record<string, unknown>
  const schemas = (spec.components as Record<string, unknown>).schemas as Record<string, unknown>

  // Generate schemas
  for (const model of schema.models) {
    const modelName = model.name

    // Main schema
    const properties: Record<string, unknown> = {}
    const required: string[] = []

    for (const field of model.fields) {
      const prop: Record<string, unknown> = {}
      const typeName = getFieldTypeName(field)

      switch (typeName) {
        case 'string':
          prop.type = 'string'
          break
        case 'int':
          prop.type = 'integer'
          break
        case 'float':
        case 'decimal':
          prop.type = 'number'
          break
        case 'boolean':
          prop.type = 'boolean'
          break
        case 'datetime':
          prop.type = 'string'
          prop.format = 'date-time'
          break
        case 'json':
          prop.type = 'object'
          break
        default:
          prop.type = 'string'
      }

      if (field.type.kind === 'array') {
        properties[field.name] = {
          type: 'array',
          items: prop,
        }
      } else {
        properties[field.name] = prop
      }

      if (field.required) {
        required.push(field.name)
      }
    }

    schemas[modelName] = {
      type: 'object',
      properties,
      required: required.length > 0 ? required : undefined,
    }

    // Create input schema
    const createProps: Record<string, unknown> = {}
    const createRequired: string[] = []

    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue

      const prop: Record<string, unknown> = {}
      const typeName = getFieldTypeName(field)
      switch (typeName) {
        case 'string':
          prop.type = 'string'
          break
        case 'int':
          prop.type = 'integer'
          break
        case 'float':
        case 'decimal':
          prop.type = 'number'
          break
        case 'boolean':
          prop.type = 'boolean'
          break
        case 'datetime':
          prop.type = 'string'
          prop.format = 'date-time'
          break
        case 'json':
          prop.type = 'object'
          break
        default:
          prop.type = 'string'
      }

      createProps[field.name] = prop

      if (field.required && field.default === undefined) {
        createRequired.push(field.name)
      }
    }

    schemas[`${modelName}CreateInput`] = {
      type: 'object',
      properties: createProps,
      required: createRequired.length > 0 ? createRequired : undefined,
    }

    schemas[`${modelName}UpdateInput`] = {
      type: 'object',
      properties: createProps,
    }
  }

  // Generate paths
  for (const model of schema.models) {
    const modelName = model.name
    const routeName = changeCase.kebabCase(modelName)
    const tag = modelName

    const listPath = `${prefix}/${routeName}`
    const itemPath = `${prefix}/${routeName}/{id}`

    // List endpoint
    if (options.methods?.includes('GET')) {
      paths[listPath] = {
        ...(paths[listPath] as Record<string, unknown>),
        get: {
          tags: [tag],
          summary: `List all ${modelName}s`,
          operationId: `list${modelName}s`,
          parameters: [
            { name: 'page', in: 'query', schema: { type: 'integer', default: 1 } },
            { name: 'limit', in: 'query', schema: { type: 'integer', default: 20 } },
            { name: 'sortBy', in: 'query', schema: { type: 'string' } },
            { name: 'sortOrder', in: 'query', schema: { type: 'string', enum: ['asc', 'desc'] } },
          ],
          responses: {
            '200': {
              description: 'Successful response',
              content: {
                'application/json': {
                  schema: {
                    type: 'object',
                    properties: {
                      data: {
                        type: 'array',
                        items: { $ref: `#/components/schemas/${modelName}` },
                      },
                      meta: {
                        type: 'object',
                        properties: {
                          total: { type: 'integer' },
                          page: { type: 'integer' },
                          limit: { type: 'integer' },
                          totalPages: { type: 'integer' },
                          hasMore: { type: 'boolean' },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      }

      paths[itemPath] = {
        ...(paths[itemPath] as Record<string, unknown>),
        get: {
          tags: [tag],
          summary: `Get ${modelName} by ID`,
          operationId: `get${modelName}ById`,
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' } }],
          responses: {
            '200': {
              description: 'Successful response',
              content: {
                'application/json': {
                  schema: { $ref: `#/components/schemas/${modelName}` },
                },
              },
            },
            '404': {
              description: 'Not found',
            },
          },
        },
      }
    }

    // Create endpoint
    if (options.methods?.includes('POST')) {
      paths[listPath] = {
        ...(paths[listPath] as Record<string, unknown>),
        post: {
          tags: [tag],
          summary: `Create ${modelName}`,
          operationId: `create${modelName}`,
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${modelName}CreateInput` },
              },
            },
          },
          responses: {
            '201': {
              description: 'Created',
              content: {
                'application/json': {
                  schema: { $ref: `#/components/schemas/${modelName}` },
                },
              },
            },
            '400': {
              description: 'Validation error',
            },
          },
        },
      }
    }

    // Update endpoint
    if (options.methods?.includes('PUT')) {
      paths[itemPath] = {
        ...(paths[itemPath] as Record<string, unknown>),
        put: {
          tags: [tag],
          summary: `Update ${modelName}`,
          operationId: `update${modelName}`,
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' } }],
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${modelName}UpdateInput` },
              },
            },
          },
          responses: {
            '200': {
              description: 'Updated',
              content: {
                'application/json': {
                  schema: { $ref: `#/components/schemas/${modelName}` },
                },
              },
            },
            '404': {
              description: 'Not found',
            },
          },
        },
      }
    }

    // Patch endpoint
    if (options.methods?.includes('PATCH')) {
      paths[itemPath] = {
        ...(paths[itemPath] as Record<string, unknown>),
        patch: {
          tags: [tag],
          summary: `Partially update ${modelName}`,
          operationId: `patch${modelName}`,
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' } }],
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${modelName}UpdateInput` },
              },
            },
          },
          responses: {
            '200': {
              description: 'Updated',
              content: {
                'application/json': {
                  schema: { $ref: `#/components/schemas/${modelName}` },
                },
              },
            },
            '404': {
              description: 'Not found',
            },
          },
        },
      }
    }

    // Delete endpoint
    if (options.methods?.includes('DELETE')) {
      paths[itemPath] = {
        ...(paths[itemPath] as Record<string, unknown>),
        delete: {
          tags: [tag],
          summary: `Delete ${modelName}`,
          operationId: `delete${modelName}`,
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' } }],
          responses: {
            '204': {
              description: 'Deleted',
            },
            '404': {
              description: 'Not found',
            },
          },
        },
      }
    }
  }

  return JSON.stringify(spec, null, 2)
}

/**
 * Generate validation schemas (Zod)
 */
function generateValidation(schema: SchemaIR): string {
  const lines: string[] = [
    '/**',
    ' * Validation Schemas',
    ' * Auto-generated by @opengenerator/gen-rest',
    ' */',
    '',
    "import { z } from 'zod'",
    '',
  ]

  for (const model of schema.models) {
    const modelName = model.name

    // Create schema
    lines.push(`export const ${changeCase.camelCase(modelName)}CreateSchema = z.object({`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue

      let zodType = 'z.string()'
      const typeName = getFieldTypeName(field)
      switch (typeName) {
        case 'string':
          zodType = 'z.string()'
          break
        case 'int':
          zodType = 'z.number().int()'
          break
        case 'float':
        case 'decimal':
          zodType = 'z.number()'
          break
        case 'boolean':
          zodType = 'z.boolean()'
          break
        case 'datetime':
          zodType = 'z.string().datetime()'
          break
        case 'json':
          zodType = 'z.record(z.unknown())'
          break
        case 'bigint':
          zodType = 'z.bigint()'
          break
      }

      if (field.type.kind === 'array') {
        zodType = `z.array(${zodType})`
      }

      if (!field.required || field.default !== undefined) {
        zodType = `${zodType}.optional()`
      }

      lines.push(`  ${field.name}: ${zodType},`)
    }
    lines.push('})')
    lines.push('')

    // Update schema (all optional)
    lines.push(
      `export const ${changeCase.camelCase(modelName)}UpdateSchema = ${changeCase.camelCase(modelName)}CreateSchema.partial()`
    )
    lines.push('')

    // Filter schema
    lines.push(
      `export const ${changeCase.camelCase(modelName)}FilterSchema = ${changeCase.camelCase(modelName)}CreateSchema.partial()`
    )
    lines.push('')
  }

  // Common schemas
  lines.push('export const paginationSchema = z.object({')
  lines.push('  page: z.number().int().positive().optional().default(1),')
  lines.push('  limit: z.number().int().positive().max(100).optional().default(20),')
  lines.push('})')
  lines.push('')

  lines.push('export const sortSchema = z.object({')
  lines.push('  sortBy: z.string().optional(),')
  lines.push("  sortOrder: z.enum(['asc', 'desc']).optional().default('asc'),")
  lines.push('})')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate index file
 */
function generateIndex(schema: SchemaIR): string {
  const lines: string[] = [
    '/**',
    ' * REST API - Main Entry',
    ' * Auto-generated by @opengenerator/gen-rest',
    ' */',
    '',
    "export * from './types'",
    "export * from './routes'",
  ]

  for (const model of schema.models) {
    lines.push(`export * from './controllers/${changeCase.kebabCase(model.name)}.controller'`)
  }

  lines.push('')

  return lines.join('\n')
}

/**
 * Create the REST generator plugin
 */
export function createRestGenerator(options: RestGeneratorOptions = {}): GeneratorPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/gen-rest',
    version: '1.0.0',
    style: 'rest',

    async generate(schema: SchemaIR, _options: GeneratorOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions }
      const files: GeneratedFile[] = []
      const dependencies: Dependency[] = []

      // Generate types
      files.push({
        path: 'types.ts',
        content: generateTypes(schema),
        type: 'source',
      })

      // Generate routes
      files.push({
        path: 'routes.ts',
        content: generateRoutes(schema, opts),
        type: 'source',
      })

      // Generate controllers
      for (const model of schema.models) {
        files.push({
          path: `controllers/${changeCase.kebabCase(model.name)}.controller.ts`,
          content: generateController(model, opts),
          type: 'source',
        })
      }

      // Generate OpenAPI spec
      if (opts.openapi) {
        files.push({
          path: 'openapi.json',
          content: generateOpenAPI(schema, opts),
          type: 'config',
        })
      }

      // Generate validation schemas
      if (opts.validation) {
        files.push({
          path: 'validation.ts',
          content: generateValidation(schema),
          type: 'source',
        })

        dependencies.push({
          name: 'zod',
          version: '^3.22.0',
          dev: false,
        })
      }

      // Generate index
      files.push({
        path: 'index.ts',
        content: generateIndex(schema),
        type: 'source',
      })

      return {
        files,
        dependencies,
        metadata: {
          generator: '@opengenerator/gen-rest',
          version: '1.0.0',
          generatedAt: new Date().toISOString(),
          options: opts,
        },
      }
    },

    getDependencies(): Dependency[] {
      const deps: Dependency[] = []

      if (mergedOptions.validation) {
        deps.push({ name: 'zod', version: '^3.22.0', dev: false })
      }

      return deps
    },
  }
}

/**
 * Default REST generator instance
 */
export const restGenerator = createRestGenerator()

export default restGenerator
