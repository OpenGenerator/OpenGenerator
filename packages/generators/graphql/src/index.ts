/**
 * @opengenerator/gen-graphql
 *
 * GraphQL API generator for OpenGenerator.
 * Generates GraphQL schema, resolvers, and type definitions.
 */

import type {
  GeneratorPlugin,
  GeneratedCode,
  GeneratedFile,
  GeneratorOptions,
  SchemaIR,
  Field,
  Dependency,
} from '@opengenerator/core'
import * as changeCase from 'change-case'

export interface GraphQLGeneratorOptions {
  /**
   * Use code-first or schema-first approach
   */
  approach?: 'code-first' | 'schema-first'

  /**
   * Generate subscriptions
   */
  subscriptions?: boolean

  /**
   * Generate relay-style connections
   */
  relay?: boolean

  /**
   * Include pagination
   */
  pagination?: boolean

  /**
   * Include filtering
   */
  filtering?: boolean

  /**
   * Include sorting
   */
  sorting?: boolean

  /**
   * Generate DataLoader patterns
   */
  dataLoader?: boolean

  /**
   * Generate input validation
   */
  validation?: boolean

  /**
   * GraphQL library to target
   */
  library?: 'graphql-yoga' | 'apollo-server' | 'mercurius' | 'generic'

  /**
   * Generate federation support
   */
  federation?: boolean

  /**
   * Custom scalar mappings
   */
  scalars?: Record<string, string>
}

const DEFAULT_OPTIONS: GraphQLGeneratorOptions = {
  approach: 'schema-first',
  subscriptions: false,
  relay: false,
  pagination: true,
  filtering: true,
  sorting: true,
  dataLoader: true,
  validation: true,
  library: 'graphql-yoga',
  federation: false,
}

/**
 * Get the scalar type name from a field
 */
function getFieldTypeName(field: Field): string {
  if (field.type.kind === 'scalar') {
    return field.type.type
  }
  return 'string'
}

/**
 * Map field type to GraphQL type
 */
function fieldToGraphQLType(field: Field): string {
  const typeMap: Record<string, string> = {
    string: 'String',
    int: 'Int',
    float: 'Float',
    boolean: 'Boolean',
    datetime: 'DateTime',
    json: 'JSON',
    bigint: 'BigInt',
    decimal: 'Decimal',
    bytes: 'Bytes',
  }

  const typeName = getFieldTypeName(field)
  let gqlType = typeMap[typeName] || 'String'

  if (field.type.kind === 'array') {
    gqlType = `[${gqlType}!]`
  }

  if (field.required) {
    gqlType = `${gqlType}!`
  }

  return gqlType
}

/**
 * Generate GraphQL schema (SDL)
 */
function generateSchema(schema: SchemaIR, options: GraphQLGeneratorOptions): string {
  const lines: string[] = [
    '# Auto-generated GraphQL Schema',
    '# DO NOT EDIT - Generated by @opengenerator/gen-graphql',
    '',
  ]

  // Custom scalars
  lines.push('scalar DateTime')
  lines.push('scalar JSON')
  lines.push('scalar BigInt')
  lines.push('scalar Decimal')
  lines.push('scalar Bytes')
  lines.push('')

  // Enums
  for (const enumDef of schema.enums || []) {
    lines.push(`enum ${enumDef.name} {`)
    for (const value of enumDef.values) {
      lines.push(`  ${value.name}`)
    }
    lines.push('}')
    lines.push('')
  }

  // Types
  for (const model of schema.models) {
    lines.push(`type ${model.name} {`)
    for (const field of model.fields) {
      const gqlType = fieldToGraphQLType(field)
      const fieldDescription = field.description ? `  """${field.description}"""` : ''
      if (fieldDescription) lines.push(fieldDescription)
      lines.push(`  ${field.name}: ${gqlType}`)
    }

    // Add relation fields
    const modelRelations = schema.relations.filter(r => r.from.model === model.name)
    for (const relation of modelRelations) {
      const relationType =
        relation.type === 'one-to-many' ? `[${relation.to.model}!]!` : `${relation.to.model}`
      lines.push(`  ${relation.name}: ${relationType}`)
    }

    lines.push('}')
    lines.push('')
  }

  // Input types
  for (const model of schema.models) {
    // Create input
    lines.push(`input ${model.name}CreateInput {`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue
      let gqlType = fieldToGraphQLType(field)
      // Make optional if has default
      if (field.default !== undefined) {
        gqlType = gqlType.replace(/!$/, '')
      }
      lines.push(`  ${field.name}: ${gqlType}`)
    }
    lines.push('}')
    lines.push('')

    // Update input
    lines.push(`input ${model.name}UpdateInput {`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue
      // All fields optional for update
      const gqlType = fieldToGraphQLType(field).replace(/!$/, '')
      lines.push(`  ${field.name}: ${gqlType}`)
    }
    lines.push('}')
    lines.push('')

    // Filter input
    if (options.filtering) {
      lines.push(`input ${model.name}FilterInput {`)
      for (const field of model.fields) {
        const typeName = getFieldTypeName(field)
        if (typeName === 'json') continue
        const baseType = fieldToGraphQLType(field).replace(/!$/, '').replace(/\[|\]/g, '')
        lines.push(`  ${field.name}: ${baseType}`)
        if (typeName === 'string') {
          lines.push(`  ${field.name}_contains: String`)
          lines.push(`  ${field.name}_startsWith: String`)
          lines.push(`  ${field.name}_endsWith: String`)
        }
        if (['int', 'float', 'datetime', 'bigint', 'decimal'].includes(typeName)) {
          lines.push(`  ${field.name}_gt: ${baseType}`)
          lines.push(`  ${field.name}_gte: ${baseType}`)
          lines.push(`  ${field.name}_lt: ${baseType}`)
          lines.push(`  ${field.name}_lte: ${baseType}`)
        }
      }
      lines.push(`  AND: [${model.name}FilterInput!]`)
      lines.push(`  OR: [${model.name}FilterInput!]`)
      lines.push(`  NOT: ${model.name}FilterInput`)
      lines.push('}')
      lines.push('')
    }

    // Order input
    if (options.sorting) {
      lines.push(`input ${model.name}OrderByInput {`)
      for (const field of model.fields) {
        const typeName = getFieldTypeName(field)
        if (typeName !== 'json') {
          lines.push(`  ${field.name}: SortOrder`)
        }
      }
      lines.push('}')
      lines.push('')
    }
  }

  // Sort order enum
  if (options.sorting) {
    lines.push('enum SortOrder {')
    lines.push('  asc')
    lines.push('  desc')
    lines.push('}')
    lines.push('')
  }

  // Pagination types
  if (options.pagination) {
    lines.push('type PageInfo {')
    lines.push('  hasNextPage: Boolean!')
    lines.push('  hasPreviousPage: Boolean!')
    lines.push('  startCursor: String')
    lines.push('  endCursor: String')
    lines.push('}')
    lines.push('')

    for (const model of schema.models) {
      if (options.relay) {
        lines.push(`type ${model.name}Edge {`)
        lines.push(`  node: ${model.name}!`)
        lines.push('  cursor: String!')
        lines.push('}')
        lines.push('')

        lines.push(`type ${model.name}Connection {`)
        lines.push(`  edges: [${model.name}Edge!]!`)
        lines.push('  pageInfo: PageInfo!')
        lines.push('  totalCount: Int!')
        lines.push('}')
        lines.push('')
      } else {
        lines.push(`type ${model.name}List {`)
        lines.push(`  items: [${model.name}!]!`)
        lines.push('  total: Int!')
        lines.push('  page: Int!')
        lines.push('  limit: Int!')
        lines.push('  totalPages: Int!')
        lines.push('  hasMore: Boolean!')
        lines.push('}')
        lines.push('')
      }
    }
  }

  // Query type
  lines.push('type Query {')
  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)
    const plural = `${name}s`
    const listType = options.relay
      ? `${model.name}Connection`
      : options.pagination
        ? `${model.name}List`
        : `[${model.name}!]!`

    // List query
    const args: string[] = []
    if (options.filtering) args.push(`filter: ${model.name}FilterInput`)
    if (options.sorting) args.push(`orderBy: ${model.name}OrderByInput`)
    if (options.pagination) {
      if (options.relay) {
        args.push('first: Int', 'after: String', 'last: Int', 'before: String')
      } else {
        args.push('page: Int', 'limit: Int')
      }
    }

    const argsStr = args.length > 0 ? `(${args.join(', ')})` : ''
    lines.push(`  ${plural}${argsStr}: ${listType}!`)

    // Single query
    lines.push(`  ${name}(id: ID!): ${model.name}`)
  }
  lines.push('}')
  lines.push('')

  // Mutation type
  lines.push('type Mutation {')
  for (const model of schema.models) {
    lines.push(`  create${model.name}(data: ${model.name}CreateInput!): ${model.name}!`)
    lines.push(
      `  update${model.name}(id: ID!, data: ${model.name}UpdateInput!): ${model.name}!`
    )
    lines.push(`  delete${model.name}(id: ID!): ${model.name}`)
    lines.push(`  deleteMany${model.name}s(filter: ${model.name}FilterInput): Int!`)
  }
  lines.push('}')
  lines.push('')

  // Subscription type
  if (options.subscriptions) {
    lines.push('type Subscription {')
    for (const model of schema.models) {
      const name = changeCase.camelCase(model.name)
      lines.push(`  ${name}Created: ${model.name}!`)
      lines.push(`  ${name}Updated: ${model.name}!`)
      lines.push(`  ${name}Deleted: ${model.name}!`)
    }
    lines.push('}')
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Generate TypeScript types from schema
 */
function generateTypes(schema: SchemaIR): string {
  const lines: string[] = [
    '/**',
    ' * GraphQL TypeScript Types',
    ' * Auto-generated by @opengenerator/gen-graphql',
    ' */',
    '',
  ]

  // Enums
  for (const enumDef of schema.enums || []) {
    lines.push(`export enum ${enumDef.name} {`)
    for (const value of enumDef.values) {
      lines.push(`  ${value.name} = '${value.value || value.name}',`)
    }
    lines.push('}')
    lines.push('')
  }

  // Types
  for (const model of schema.models) {
    lines.push(`export interface ${model.name} {`)
    for (const field of model.fields) {
      const tsType = fieldToTsType(field)
      lines.push(`  ${field.name}: ${tsType}`)
    }
    lines.push('}')
    lines.push('')

    // Create input
    lines.push(`export interface ${model.name}CreateInput {`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue
      const optional = !field.required || field.default !== undefined ? '?' : ''
      lines.push(`  ${field.name}${optional}: ${fieldToTsType(field)}`)
    }
    lines.push('}')
    lines.push('')

    // Update input
    lines.push(`export interface ${model.name}UpdateInput {`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue
      lines.push(`  ${field.name}?: ${fieldToTsType(field)}`)
    }
    lines.push('}')
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Field to TypeScript type
 */
function fieldToTsType(field: Field): string {
  const typeMap: Record<string, string> = {
    string: 'string',
    int: 'number',
    float: 'number',
    boolean: 'boolean',
    datetime: 'Date',
    json: 'Record<string, unknown>',
    bigint: 'bigint',
    decimal: 'string',
    bytes: 'Buffer',
  }

  const typeName = getFieldTypeName(field)
  let tsType = typeMap[typeName] || 'unknown'

  if (field.type.kind === 'array') {
    tsType = `${tsType}[]`
  }

  if (!field.required) {
    tsType = `${tsType} | null`
  }

  return tsType
}

/**
 * Generate resolvers
 */
function generateResolvers(schema: SchemaIR, options: GraphQLGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * GraphQL Resolvers',
    ' * Auto-generated by @opengenerator/gen-graphql',
    ' */',
    '',
    "import type { Context } from './context'",
    "import type * as Types from './types'",
    '',
    'export const resolvers = {',
    '  Query: {',
  ]

  // Query resolvers
  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)
    const plural = `${name}s`

    lines.push(`    ${plural}: async (_parent: unknown, args: {`)
    if (options.filtering) lines.push(`      filter?: Types.${model.name}FilterInput`)
    if (options.sorting) lines.push(`      orderBy?: Types.${model.name}OrderByInput`)
    if (options.pagination) {
      lines.push('      page?: number')
      lines.push('      limit?: number')
    }
    lines.push('    }, context: Context) => {')
    lines.push(`      const { filter, orderBy, page = 1, limit = 20 } = args`)
    lines.push(`      return context.repositories.${name}.findMany({ filter, orderBy, page, limit })`)
    lines.push('    },')
    lines.push('')

    lines.push(
      `    ${name}: async (_parent: unknown, args: { id: string }, context: Context) => {`
    )
    lines.push(`      return context.repositories.${name}.findById(args.id)`)
    lines.push('    },')
    lines.push('')
  }

  lines.push('  },')
  lines.push('')
  lines.push('  Mutation: {')

  // Mutation resolvers
  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)

    lines.push(
      `    create${model.name}: async (_parent: unknown, args: { data: Types.${model.name}CreateInput }, context: Context) => {`
    )
    lines.push(`      return context.repositories.${name}.create(args.data)`)
    lines.push('    },')
    lines.push('')

    lines.push(
      `    update${model.name}: async (_parent: unknown, args: { id: string; data: Types.${model.name}UpdateInput }, context: Context) => {`
    )
    lines.push(`      return context.repositories.${name}.update(args.id, args.data)`)
    lines.push('    },')
    lines.push('')

    lines.push(
      `    delete${model.name}: async (_parent: unknown, args: { id: string }, context: Context) => {`
    )
    lines.push(`      return context.repositories.${name}.delete(args.id)`)
    lines.push('    },')
    lines.push('')

    lines.push(
      `    deleteMany${model.name}s: async (_parent: unknown, args: { filter?: Types.${model.name}FilterInput }, context: Context) => {`
    )
    lines.push(`      return context.repositories.${name}.deleteMany(args.filter)`)
    lines.push('    },')
    lines.push('')
  }

  lines.push('  },')
  lines.push('')

  // Type resolvers for relations
  for (const model of schema.models) {
    const modelRelations = schema.relations.filter(r => r.from.model === model.name)
    if (modelRelations.length > 0) {
      lines.push(`  ${model.name}: {`)
      for (const relation of modelRelations) {
        const relName = changeCase.camelCase(relation.to.model)
        if (relation.type === 'one-to-many') {
          lines.push(
            `    ${relation.name}: async (parent: Types.${model.name}, _args: unknown, context: Context) => {`
          )
          lines.push(
            `      return context.repositories.${relName}.findMany({ filter: { ${relation.from.field}: parent.id } })`
          )
          lines.push('    },')
        } else {
          lines.push(
            `    ${relation.name}: async (parent: Types.${model.name}, _args: unknown, context: Context) => {`
          )
          lines.push(
            `      return context.repositories.${relName}.findById(parent.${relation.from.field})`
          )
          lines.push('    },')
        }
      }
      lines.push('  },')
      lines.push('')
    }
  }

  // Subscriptions
  if (options.subscriptions) {
    lines.push('  Subscription: {')
    for (const model of schema.models) {
      const name = changeCase.camelCase(model.name)
      lines.push(`    ${name}Created: {`)
      lines.push(`      subscribe: (_parent: unknown, _args: unknown, context: Context) => {`)
      lines.push(`        return context.pubsub.subscribe('${model.name.toUpperCase()}_CREATED')`)
      lines.push('      },')
      lines.push('    },')
      lines.push(`    ${name}Updated: {`)
      lines.push(`      subscribe: (_parent: unknown, _args: unknown, context: Context) => {`)
      lines.push(`        return context.pubsub.subscribe('${model.name.toUpperCase()}_UPDATED')`)
      lines.push('      },')
      lines.push('    },')
      lines.push(`    ${name}Deleted: {`)
      lines.push(`      subscribe: (_parent: unknown, _args: unknown, context: Context) => {`)
      lines.push(`        return context.pubsub.subscribe('${model.name.toUpperCase()}_DELETED')`)
      lines.push('      },')
      lines.push('    },')
    }
    lines.push('  },')
    lines.push('')
  }

  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate context file
 */
function generateContext(schema: SchemaIR, options: GraphQLGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * GraphQL Context',
    ' * Auto-generated by @opengenerator/gen-graphql',
    ' */',
    '',
    "import type * as Types from './types'",
    '',
    'export interface Repositories {',
  ]

  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)
    lines.push(`  ${name}: {`)
    lines.push(
      `    findMany(params: { filter?: any; orderBy?: any; page?: number; limit?: number }): Promise<{ items: Types.${model.name}[]; total: number }>`
    )
    lines.push(`    findById(id: string): Promise<Types.${model.name} | null>`)
    lines.push(`    create(data: Types.${model.name}CreateInput): Promise<Types.${model.name}>`)
    lines.push(
      `    update(id: string, data: Types.${model.name}UpdateInput): Promise<Types.${model.name}>`
    )
    lines.push(`    delete(id: string): Promise<Types.${model.name}>`)
    lines.push(`    deleteMany(filter?: any): Promise<number>`)
    lines.push('  }')
  }

  lines.push('}')
  lines.push('')

  lines.push('export interface Context {')
  lines.push('  repositories: Repositories')
  if (options.subscriptions) {
    lines.push('  pubsub: {')
    lines.push('    publish(event: string, payload: unknown): void')
    lines.push('    subscribe(event: string): AsyncIterator<unknown>')
    lines.push('  }')
  }
  if (options.dataLoader) {
    lines.push('  loaders: Record<string, unknown>')
  }
  lines.push('  user?: { id: string; [key: string]: unknown }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate DataLoader file
 */
function generateDataLoaders(schema: SchemaIR): string {
  const lines: string[] = [
    '/**',
    ' * GraphQL DataLoaders',
    ' * Auto-generated by @opengenerator/gen-graphql',
    ' */',
    '',
    "import DataLoader from 'dataloader'",
    "import type { Repositories } from './context'",
    "import type * as Types from './types'",
    '',
    'export function createLoaders(repositories: Repositories) {',
    '  return {',
  ]

  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)
    lines.push(
      `    ${name}: new DataLoader<string, Types.${model.name} | null>(async (ids) => {`
    )
    lines.push(
      `      const items = await repositories.${name}.findMany({ filter: { id_in: ids as string[] } })`
    )
    lines.push('      const itemMap = new Map(items.items.map(item => [item.id, item]))')
    lines.push('      return ids.map(id => itemMap.get(id) || null)')
    lines.push('    }),')
  }

  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate index file
 */
function generateIndex(_schema: SchemaIR, options: GraphQLGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * GraphQL API - Main Entry',
    ' * Auto-generated by @opengenerator/gen-graphql',
    ' */',
    '',
    "export { resolvers } from './resolvers'",
    "export * from './types'",
    "export * from './context'",
  ]

  if (options.dataLoader) {
    lines.push("export { createLoaders } from './dataloaders'")
  }

  lines.push('')
  lines.push("import { readFileSync } from 'fs'")
  lines.push("import { join } from 'path'")
  lines.push('')
  lines.push('export const typeDefs = readFileSync(')
  lines.push("  join(__dirname, 'schema.graphql'),")
  lines.push("  'utf-8'"
  )
  lines.push(')')
  lines.push('')

  return lines.join('\n')
}

/**
 * Create the GraphQL generator plugin
 */
export function createGraphQLGenerator(options: GraphQLGeneratorOptions = {}): GeneratorPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/gen-graphql',
    version: '1.0.0',
    style: 'graphql',

    async generate(
      schema: SchemaIR,
      _options: GeneratorOptions
    ): Promise<GeneratedCode> {
      const opts = { ...mergedOptions }
      const files: GeneratedFile[] = []
      const dependencies: Dependency[] = []

      // Generate schema
      files.push({
        path: 'schema.graphql',
        content: generateSchema(schema, opts),
        type: 'config',
      })

      // Generate types
      files.push({
        path: 'types.ts',
        content: generateTypes(schema),
        type: 'source',
      })

      // Generate resolvers
      files.push({
        path: 'resolvers.ts',
        content: generateResolvers(schema, opts),
        type: 'source',
      })

      // Generate context
      files.push({
        path: 'context.ts',
        content: generateContext(schema, opts),
        type: 'source',
      })

      // Generate DataLoaders
      if (opts.dataLoader) {
        files.push({
          path: 'dataloaders.ts',
          content: generateDataLoaders(schema),
          type: 'source',
        })

        dependencies.push({
          name: 'dataloader',
          version: '^2.2.0',
          dev: false,
        })
      }

      // Generate index
      files.push({
        path: 'index.ts',
        content: generateIndex(schema, opts),
        type: 'source',
      })

      // Add library-specific dependencies
      dependencies.push({
        name: 'graphql',
        version: '^16.8.0',
        dev: false,
      })

      if (opts.library === 'graphql-yoga') {
        dependencies.push({
          name: 'graphql-yoga',
          version: '^5.1.0',
          dev: false,
        })
      } else if (opts.library === 'apollo-server') {
        dependencies.push({
          name: '@apollo/server',
          version: '^4.10.0',
          dev: false,
        })
      }

      return {
        files,
        dependencies,
        metadata: {
          generator: '@opengenerator/gen-graphql',
          version: '1.0.0',
          generatedAt: new Date().toISOString(),
          options: opts,
        },
      }
    },

    getDependencies(): Dependency[] {
      const deps: Dependency[] = [
        { name: 'graphql', version: '^16.8.0', dev: false },
      ]

      if (mergedOptions.library === 'graphql-yoga') {
        deps.push({ name: 'graphql-yoga', version: '^5.1.0', dev: false })
      } else if (mergedOptions.library === 'apollo-server') {
        deps.push({ name: '@apollo/server', version: '^4.10.0', dev: false })
      }

      if (mergedOptions.dataLoader) {
        deps.push({ name: 'dataloader', version: '^2.2.0', dev: false })
      }

      return deps
    },
  }
}

/**
 * Default GraphQL generator instance
 */
export const graphqlGenerator = createGraphQLGenerator()

export default graphqlGenerator
