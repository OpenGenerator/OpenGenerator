/**
 * @opengenerator/gen-trpc
 *
 * tRPC API generator for OpenGenerator.
 * Generates type-safe tRPC routers, procedures, and client.
 */

import type {
  GeneratorPlugin,
  GeneratedCode,
  GeneratedFile,
  GeneratorOptions,
  SchemaIR,
  Field,
  Dependency,
  Model,
} from '@opengenerator/core'
import * as changeCase from 'change-case'

export interface TRPCGeneratorOptions {
  /**
   * tRPC version
   */
  version?: 10 | 11

  /**
   * Generate React Query hooks
   */
  react?: boolean

  /**
   * Generate subscriptions
   */
  subscriptions?: boolean

  /**
   * Include pagination
   */
  pagination?: boolean

  /**
   * Include filtering
   */
  filtering?: boolean

  /**
   * Include sorting
   */
  sorting?: boolean

  /**
   * Generate input validation with Zod
   */
  validation?: boolean

  /**
   * Generate client
   */
  client?: boolean

  /**
   * SuperJSON transformer
   */
  superjson?: boolean

  /**
   * Generate batch requests
   */
  batching?: boolean
}

const DEFAULT_OPTIONS: TRPCGeneratorOptions = {
  version: 11,
  react: true,
  subscriptions: false,
  pagination: true,
  filtering: true,
  sorting: true,
  validation: true,
  client: true,
  superjson: true,
  batching: true,
}

/**
 * Get the scalar type name from a field
 */
function getFieldTypeName(field: Field): string {
  if (field.type.kind === 'scalar') {
    return field.type.type
  }
  return 'string'
}

/**
 * Map field type to Zod type
 */
function fieldToZodType(field: Field): string {
  const typeMap: Record<string, string> = {
    string: 'z.string()',
    int: 'z.number().int()',
    float: 'z.number()',
    boolean: 'z.boolean()',
    datetime: 'z.date()',
    json: 'z.record(z.unknown())',
    bigint: 'z.bigint()',
    decimal: 'z.string()',
    bytes: 'z.instanceof(Buffer)',
  }

  const typeName = getFieldTypeName(field)
  let zodType = typeMap[typeName] || 'z.unknown()'

  if (field.type.kind === 'array') {
    zodType = `z.array(${zodType})`
  }

  if (!field.required) {
    zodType = `${zodType}.nullable().optional()`
  }

  return zodType
}

/**
 * Generate Zod schemas
 */
function generateSchemas(schema: SchemaIR): string {
  const lines: string[] = [
    '/**',
    ' * tRPC Zod Schemas',
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "import { z } from 'zod'",
    '',
  ]

  for (const model of schema.models) {
    const modelName = model.name
    const schemaName = `${changeCase.camelCase(modelName)}Schema`

    // Base schema
    lines.push(`export const ${schemaName} = z.object({`)
    for (const field of model.fields) {
      lines.push(`  ${field.name}: ${fieldToZodType(field)},`)
    }
    lines.push('})')
    lines.push('')

    // Create input schema
    lines.push(`export const ${changeCase.camelCase(modelName)}CreateInput = z.object({`)
    for (const field of model.fields) {
      if (field.primaryKey || field.name === 'createdAt' || field.name === 'updatedAt') continue
      let zodType = fieldToZodType(field)
      if (field.default !== undefined) {
        zodType = `${zodType}.optional()`
      }
      lines.push(`  ${field.name}: ${zodType},`)
    }
    lines.push('})')
    lines.push('')

    // Update input schema
    lines.push(
      `export const ${changeCase.camelCase(modelName)}UpdateInput = ${changeCase.camelCase(modelName)}CreateInput.partial()`
    )
    lines.push('')

    // Filter schema
    lines.push(`export const ${changeCase.camelCase(modelName)}FilterInput = z.object({`)
    for (const field of model.fields) {
      const typeName = getFieldTypeName(field)
      if (typeName === 'json') continue
      const baseZod = fieldToZodType(field).replace('.nullable().optional()', '')
      lines.push(`  ${field.name}: ${baseZod}.optional(),`)
      if (typeName === 'string') {
        lines.push(`  ${field.name}_contains: z.string().optional(),`)
        lines.push(`  ${field.name}_startsWith: z.string().optional(),`)
        lines.push(`  ${field.name}_endsWith: z.string().optional(),`)
      }
      if (['int', 'float', 'datetime', 'bigint', 'decimal'].includes(typeName)) {
        lines.push(`  ${field.name}_gt: ${baseZod}.optional(),`)
        lines.push(`  ${field.name}_gte: ${baseZod}.optional(),`)
        lines.push(`  ${field.name}_lt: ${baseZod}.optional(),`)
        lines.push(`  ${field.name}_lte: ${baseZod}.optional(),`)
      }
    }
    lines.push('}).partial()')
    lines.push('')

    // Types
    lines.push(`export type ${modelName} = z.infer<typeof ${schemaName}>`)
    lines.push(
      `export type ${modelName}CreateInput = z.infer<typeof ${changeCase.camelCase(modelName)}CreateInput>`
    )
    lines.push(
      `export type ${modelName}UpdateInput = z.infer<typeof ${changeCase.camelCase(modelName)}UpdateInput>`
    )
    lines.push(
      `export type ${modelName}Filter = z.infer<typeof ${changeCase.camelCase(modelName)}FilterInput>`
    )
    lines.push('')
  }

  // Pagination schema
  lines.push('export const paginationInput = z.object({')
  lines.push('  page: z.number().int().positive().default(1),')
  lines.push('  limit: z.number().int().positive().max(100).default(20),')
  lines.push('})')
  lines.push('')

  // Sort schema
  lines.push('export const sortInput = z.object({')
  lines.push('  field: z.string(),')
  lines.push("  order: z.enum(['asc', 'desc']).default('asc'),")
  lines.push('})')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate router for a model
 */
function generateModelRouter(model: Model, options: TRPCGeneratorOptions): string {
  const name = changeCase.camelCase(model.name)
  const Name = model.name

  const lines: string[] = [
    '/**',
    ` * ${Name} Router`,
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "import { z } from 'zod'",
    "import { router, publicProcedure, protectedProcedure } from '../trpc'",
    `import { ${name}Schema, ${name}CreateInput, ${name}UpdateInput, ${name}FilterInput, paginationInput, sortInput } from '../schemas'`,
    '',
    `export const ${name}Router = router({`,
  ]

  // List procedure
  lines.push('  list: publicProcedure')
  lines.push('    .input(')
  lines.push('      z.object({')
  if (options.filtering) {
    lines.push(`        filter: ${name}FilterInput.optional(),`)
  }
  if (options.pagination) {
    lines.push('        pagination: paginationInput.optional(),')
  }
  if (options.sorting) {
    lines.push('        sort: sortInput.optional(),')
  }
  lines.push('      })')
  lines.push('    )')
  lines.push('    .query(async ({ input, ctx }) => {')
  lines.push('      const { filter, pagination = { page: 1, limit: 20 }, sort } = input')
  lines.push(`      const { data, total } = await ctx.repositories.${name}.findMany({`)
  lines.push('        filter,')
  lines.push('        pagination,')
  lines.push('        sort,')
  lines.push('      })')
  lines.push('')
  lines.push('      const totalPages = Math.ceil(total / pagination.limit)')
  lines.push('')
  lines.push('      return {')
  lines.push('        items: data,')
  lines.push('        meta: {')
  lines.push('          total,')
  lines.push('          page: pagination.page,')
  lines.push('          limit: pagination.limit,')
  lines.push('          totalPages,')
  lines.push('          hasMore: pagination.page < totalPages,')
  lines.push('        },')
  lines.push('      }')
  lines.push('    }),')
  lines.push('')

  // Get by ID procedure
  lines.push('  byId: publicProcedure')
  lines.push('    .input(z.object({ id: z.string() }))')
  lines.push('    .query(async ({ input, ctx }) => {')
  lines.push(`      const item = await ctx.repositories.${name}.findById(input.id)`)
  lines.push('      if (!item) {')
  lines.push(`        throw new Error('${Name} not found')`)
  lines.push('      }')
  lines.push('      return item')
  lines.push('    }),')
  lines.push('')

  // Create procedure
  lines.push('  create: protectedProcedure')
  lines.push(`    .input(${name}CreateInput)`)
  lines.push('    .mutation(async ({ input, ctx }) => {')
  lines.push(`      return ctx.repositories.${name}.create(input)`)
  lines.push('    }),')
  lines.push('')

  // Update procedure
  lines.push('  update: protectedProcedure')
  lines.push('    .input(z.object({')
  lines.push('      id: z.string(),')
  lines.push(`      data: ${name}UpdateInput,`)
  lines.push('    }))')
  lines.push('    .mutation(async ({ input, ctx }) => {')
  lines.push(`      const existing = await ctx.repositories.${name}.findById(input.id)`)
  lines.push('      if (!existing) {')
  lines.push(`        throw new Error('${Name} not found')`)
  lines.push('      }')
  lines.push(`      return ctx.repositories.${name}.update(input.id, input.data)`)
  lines.push('    }),')
  lines.push('')

  // Delete procedure
  lines.push('  delete: protectedProcedure')
  lines.push('    .input(z.object({ id: z.string() }))')
  lines.push('    .mutation(async ({ input, ctx }) => {')
  lines.push(`      const existing = await ctx.repositories.${name}.findById(input.id)`)
  lines.push('      if (!existing) {')
  lines.push(`        throw new Error('${Name} not found')`)
  lines.push('      }')
  lines.push(`      await ctx.repositories.${name}.delete(input.id)`)
  lines.push('      return { success: true }')
  lines.push('    }),')

  // Subscriptions
  if (options.subscriptions) {
    lines.push('')
    lines.push('  onCreate: publicProcedure.subscription(({ ctx }) => {')
    lines.push(`    return ctx.pubsub.subscribe('${Name.toUpperCase()}_CREATED')`)
    lines.push('  }),')
    lines.push('')
    lines.push('  onUpdate: publicProcedure.subscription(({ ctx }) => {')
    lines.push(`    return ctx.pubsub.subscribe('${Name.toUpperCase()}_UPDATED')`)
    lines.push('  }),')
    lines.push('')
    lines.push('  onDelete: publicProcedure.subscription(({ ctx }) => {')
    lines.push(`    return ctx.pubsub.subscribe('${Name.toUpperCase()}_DELETED')`)
    lines.push('  }),')
  }

  lines.push('})')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate main router
 */
function generateMainRouter(schema: SchemaIR): string {
  const lines: string[] = [
    '/**',
    ' * tRPC App Router',
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "import { router } from './trpc'",
  ]

  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)
    lines.push(`import { ${name}Router } from './routers/${name}'`)
  }

  lines.push('')
  lines.push('export const appRouter = router({')

  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)
    lines.push(`  ${name}: ${name}Router,`)
  }

  lines.push('})')
  lines.push('')
  lines.push('export type AppRouter = typeof appRouter')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate tRPC setup file
 */
function generateTrpcSetup(options: TRPCGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * tRPC Setup',
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "import { initTRPC, TRPCError } from '@trpc/server'",
  ]

  if (options.superjson) {
    lines.push("import superjson from 'superjson'")
  }

  lines.push("import type { Context } from './context'")
  lines.push('')

  lines.push('const t = initTRPC.context<Context>().create({')
  if (options.superjson) {
    lines.push('  transformer: superjson,')
  }
  lines.push('  errorFormatter({ shape }) {')
  lines.push('    return shape')
  lines.push('  },')
  lines.push('})')
  lines.push('')

  lines.push('export const router = t.router')
  lines.push('export const publicProcedure = t.procedure')
  lines.push('')

  // Auth middleware
  lines.push('const isAuthed = t.middleware(({ ctx, next }) => {')
  lines.push('  if (!ctx.user) {')
  lines.push("    throw new TRPCError({ code: 'UNAUTHORIZED' })")
  lines.push('  }')
  lines.push('  return next({')
  lines.push('    ctx: {')
  lines.push('      ...ctx,')
  lines.push('      user: ctx.user,')
  lines.push('    },')
  lines.push('  })')
  lines.push('})')
  lines.push('')

  lines.push('export const protectedProcedure = t.procedure.use(isAuthed)')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate context file
 */
function generateContext(schema: SchemaIR, options: TRPCGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * tRPC Context',
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "import type * as Types from './schemas'",
    '',
    'export interface Repositories {',
  ]

  for (const model of schema.models) {
    const name = changeCase.camelCase(model.name)
    const Name = model.name
    lines.push(`  ${name}: {`)
    lines.push(
      `    findMany(params: { filter?: Types.${Name}Filter; pagination?: { page: number; limit: number }; sort?: { field: string; order: 'asc' | 'desc' } }): Promise<{ data: Types.${Name}[]; total: number }>`
    )
    lines.push(`    findById(id: string): Promise<Types.${Name} | null>`)
    lines.push(`    create(data: Types.${Name}CreateInput): Promise<Types.${Name}>`)
    lines.push(`    update(id: string, data: Types.${Name}UpdateInput): Promise<Types.${Name}>`)
    lines.push(`    delete(id: string): Promise<void>`)
    lines.push('  }')
  }

  lines.push('}')
  lines.push('')

  lines.push('export interface Context {')
  lines.push('  repositories: Repositories')
  if (options.subscriptions) {
    lines.push('  pubsub: {')
    lines.push('    publish(event: string, payload: unknown): void')
    lines.push('    subscribe(event: string): AsyncIterator<unknown>')
    lines.push('  }')
  }
  lines.push('  user?: { id: string; [key: string]: unknown } | null')
  lines.push('}')
  lines.push('')

  lines.push('export function createContext(opts: {')
  lines.push('  repositories: Repositories')
  lines.push('  user?: { id: string; [key: string]: unknown } | null')
  if (options.subscriptions) {
    lines.push('  pubsub?: Context["pubsub"]')
  }
  lines.push('}): Context {')
  lines.push('  return {')
  lines.push('    repositories: opts.repositories,')
  lines.push('    user: opts.user ?? null,')
  if (options.subscriptions) {
    lines.push('    pubsub: opts.pubsub!,')
  }
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate client
 */
function generateClient(options: TRPCGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * tRPC Client',
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "import { createTRPCClient, httpBatchLink } from '@trpc/client'",
  ]

  if (options.superjson) {
    lines.push("import superjson from 'superjson'")
  }

  lines.push("import type { AppRouter } from './router'")
  lines.push('')

  lines.push('export function createClient(url: string) {')
  lines.push('  return createTRPCClient<AppRouter>({')
  lines.push('    links: [')
  lines.push('      httpBatchLink({')
  lines.push('        url,')
  if (options.superjson) {
    lines.push('        transformer: superjson,')
  }
  lines.push('      }),')
  lines.push('    ],')
  lines.push('  })')
  lines.push('}')
  lines.push('')

  lines.push('export type Client = ReturnType<typeof createClient>')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate React hooks
 */
function generateReactHooks(_options: TRPCGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * tRPC React Hooks',
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "import { createTRPCReact } from '@trpc/react-query'",
    "import type { AppRouter } from './router'",
    '',
    'export const trpc = createTRPCReact<AppRouter>()',
    '',
  ]

  return lines.join('\n')
}

/**
 * Generate index file
 */
function generateIndex(_schema: SchemaIR, options: TRPCGeneratorOptions): string {
  const lines: string[] = [
    '/**',
    ' * tRPC API - Main Entry',
    ' * Auto-generated by @opengenerator/gen-trpc',
    ' */',
    '',
    "export { appRouter, type AppRouter } from './router'",
    "export * from './schemas'",
    "export * from './context'",
    "export { router, publicProcedure, protectedProcedure } from './trpc'",
  ]

  if (options.client) {
    lines.push("export { createClient, type Client } from './client'")
  }

  if (options.react) {
    lines.push("export { trpc } from './react'")
  }

  lines.push('')

  return lines.join('\n')
}

/**
 * Create the tRPC generator plugin
 */
export function createTRPCGenerator(options: TRPCGeneratorOptions = {}): GeneratorPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/gen-trpc',
    version: '1.0.0',
    style: 'trpc',

    async generate(schema: SchemaIR, _options: GeneratorOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions }
      const files: GeneratedFile[] = []
      const dependencies: Dependency[] = []

      // Generate schemas
      files.push({
        path: 'schemas.ts',
        content: generateSchemas(schema),
        type: 'source',
      })

      // Generate tRPC setup
      files.push({
        path: 'trpc.ts',
        content: generateTrpcSetup(opts),
        type: 'source',
      })

      // Generate context
      files.push({
        path: 'context.ts',
        content: generateContext(schema, opts),
        type: 'source',
      })

      // Generate routers
      for (const model of schema.models) {
        const name = changeCase.camelCase(model.name)
        files.push({
          path: `routers/${name}.ts`,
          content: generateModelRouter(model, opts),
          type: 'source',
        })
      }

      // Generate main router
      files.push({
        path: 'router.ts',
        content: generateMainRouter(schema),
        type: 'source',
      })

      // Generate client
      if (opts.client) {
        files.push({
          path: 'client.ts',
          content: generateClient(opts),
          type: 'source',
        })
      }

      // Generate React hooks
      if (opts.react) {
        files.push({
          path: 'react.ts',
          content: generateReactHooks(opts),
          type: 'source',
        })
      }

      // Generate index
      files.push({
        path: 'index.ts',
        content: generateIndex(schema, opts),
        type: 'source',
      })

      // Dependencies
      dependencies.push(
        { name: '@trpc/server', version: '^11.0.0', dev: false },
        { name: '@trpc/client', version: '^11.0.0', dev: false },
        { name: 'zod', version: '^3.22.0', dev: false }
      )

      if (opts.superjson) {
        dependencies.push({ name: 'superjson', version: '^2.2.0', dev: false })
      }

      if (opts.react) {
        dependencies.push(
          { name: '@trpc/react-query', version: '^11.0.0', dev: false },
          { name: '@tanstack/react-query', version: '^5.0.0', dev: false }
        )
      }

      return {
        files,
        dependencies,
        metadata: {
          generator: '@opengenerator/gen-trpc',
          version: '1.0.0',
          generatedAt: new Date().toISOString(),
          options: opts,
        },
      }
    },

    getDependencies(): Dependency[] {
      const deps: Dependency[] = [
        { name: '@trpc/server', version: '^11.0.0', dev: false },
        { name: '@trpc/client', version: '^11.0.0', dev: false },
        { name: 'zod', version: '^3.22.0', dev: false },
      ]

      if (mergedOptions.superjson) {
        deps.push({ name: 'superjson', version: '^2.2.0', dev: false })
      }

      if (mergedOptions.react) {
        deps.push(
          { name: '@trpc/react-query', version: '^11.0.0', dev: false },
          { name: '@tanstack/react-query', version: '^5.0.0', dev: false }
        )
      }

      return deps
    },
  }
}

/**
 * Default tRPC generator instance
 */
export const trpcGenerator = createTRPCGenerator()

export default trpcGenerator
