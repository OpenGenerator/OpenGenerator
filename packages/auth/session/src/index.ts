/**
 * @opengenerator/auth-session
 *
 * Session-based authentication plugin for OpenGenerator.
 */

import type {
  AuthPlugin,
  AuthOptions,
  GeneratedCode,
  GeneratedFile,
  SchemaIR,
  Dependency,
  MiddlewareDefinition,
} from '@opengenerator/core'

export interface SessionOptions {
  store?: 'memory' | 'redis' | 'database'
  maxAge?: number
  cookieName?: string
  secure?: boolean
  httpOnly?: boolean
  sameSite?: 'strict' | 'lax' | 'none'
}

const DEFAULT_OPTIONS: SessionOptions = {
  store: 'memory',
  maxAge: 86400000, // 24 hours
  cookieName: 'sid',
  secure: true,
  httpOnly: true,
  sameSite: 'lax',
}

function generateSessionService(options: SessionOptions): string {
  return `/**
 * Session Service
 * Auto-generated by @opengenerator/auth-session
 */

import { randomBytes, createHash } from 'crypto'

export interface Session {
  id: string
  userId: string
  data: Record<string, unknown>
  createdAt: Date
  expiresAt: Date
}

export interface SessionStore {
  get(id: string): Promise<Session | null>
  set(session: Session): Promise<void>
  delete(id: string): Promise<void>
  touch(id: string, expiresAt: Date): Promise<void>
}

class MemoryStore implements SessionStore {
  private sessions = new Map<string, Session>()

  async get(id: string): Promise<Session | null> {
    const session = this.sessions.get(id)
    if (!session) return null
    if (session.expiresAt < new Date()) {
      this.sessions.delete(id)
      return null
    }
    return session
  }

  async set(session: Session): Promise<void> {
    this.sessions.set(session.id, session)
  }

  async delete(id: string): Promise<void> {
    this.sessions.delete(id)
  }

  async touch(id: string, expiresAt: Date): Promise<void> {
    const session = this.sessions.get(id)
    if (session) {
      session.expiresAt = expiresAt
    }
  }
}

export interface SessionConfig {
  store: SessionStore
  maxAge: number
  cookieName: string
  secure: boolean
  httpOnly: boolean
  sameSite: 'strict' | 'lax' | 'none'
}

const defaultConfig: SessionConfig = {
  store: new MemoryStore(),
  maxAge: ${options.maxAge || 86400000},
  cookieName: '${options.cookieName || 'sid'}',
  secure: ${options.secure ?? true},
  httpOnly: ${options.httpOnly ?? true},
  sameSite: '${options.sameSite || 'lax'}',
}

function generateSessionId(): string {
  return createHash('sha256')
    .update(randomBytes(32))
    .digest('hex')
}

export class SessionService {
  private config: SessionConfig

  constructor(config: Partial<SessionConfig> = {}) {
    this.config = { ...defaultConfig, ...config }
  }

  async create(userId: string, data: Record<string, unknown> = {}): Promise<Session> {
    const now = new Date()
    const session: Session = {
      id: generateSessionId(),
      userId,
      data,
      createdAt: now,
      expiresAt: new Date(now.getTime() + this.config.maxAge),
    }
    await this.config.store.set(session)
    return session
  }

  async get(sessionId: string): Promise<Session | null> {
    return this.config.store.get(sessionId)
  }

  async destroy(sessionId: string): Promise<void> {
    await this.config.store.delete(sessionId)
  }

  async refresh(sessionId: string): Promise<Session | null> {
    const session = await this.config.store.get(sessionId)
    if (!session) return null

    const expiresAt = new Date(Date.now() + this.config.maxAge)
    await this.config.store.touch(sessionId, expiresAt)
    session.expiresAt = expiresAt
    return session
  }

  getCookieOptions() {
    return {
      name: this.config.cookieName,
      maxAge: this.config.maxAge,
      secure: this.config.secure,
      httpOnly: this.config.httpOnly,
      sameSite: this.config.sameSite,
      path: '/',
    }
  }

  serializeCookie(sessionId: string): string {
    const opts = this.getCookieOptions()
    const parts = [
      \`\${opts.name}=\${sessionId}\`,
      \`Max-Age=\${Math.floor(opts.maxAge / 1000)}\`,
      \`Path=\${opts.path}\`,
      opts.httpOnly && 'HttpOnly',
      opts.secure && 'Secure',
      \`SameSite=\${opts.sameSite}\`,
    ].filter(Boolean)
    return parts.join('; ')
  }

  parseCookie(cookieHeader: string): string | null {
    const cookies = cookieHeader.split(';').reduce((acc, part) => {
      const [key, value] = part.trim().split('=')
      acc[key] = value
      return acc
    }, {} as Record<string, string>)
    return cookies[this.config.cookieName] || null
  }
}

export const sessionService = new SessionService()
`
}

function generateIndex(): string {
  return `export { SessionService, sessionService, type Session, type SessionStore, type SessionConfig } from './session-service'
`
}

export function createSessionAuth(options: SessionOptions = {}): AuthPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/auth-session',
    version: '1.0.0',
    strategy: 'session',

    async generate(_schema: SchemaIR, _options: AuthOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions, ...(_options as unknown as SessionOptions) }
      const files: GeneratedFile[] = []

      files.push({ path: 'session-service.ts', content: generateSessionService(opts), type: 'source' })
      files.push({ path: 'index.ts', content: generateIndex(), type: 'source' })

      return {
        files,
        dependencies: [],
        metadata: { auth: '@opengenerator/auth-session', version: '1.0.0', options: opts },
      }
    },

    getMiddleware(): MiddlewareDefinition[] {
      return []
    },

    getDependencies(): Dependency[] {
      return []
    },
  }
}

export const sessionAuth = createSessionAuth()
export default sessionAuth
