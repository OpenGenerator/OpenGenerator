/**
 * @opengenerator/auth-apikey
 *
 * API Key authentication plugin for OpenGenerator.
 */

import type {
  AuthPlugin,
  AuthOptions,
  GeneratedCode,
  GeneratedFile,
  SchemaIR,
  Dependency,
  MiddlewareDefinition,
} from '@opengenerator/core'

export interface ApiKeyOptions {
  prefix?: string
  headerName?: string
  queryParam?: string
  hashAlgorithm?: 'sha256' | 'sha512'
}

const DEFAULT_OPTIONS: ApiKeyOptions = {
  prefix: 'og_',
  headerName: 'X-API-Key',
  queryParam: 'api_key',
  hashAlgorithm: 'sha256',
}

function generateApiKeyService(options: ApiKeyOptions): string {
  return `/**
 * API Key Service
 * Auto-generated by @opengenerator/auth-apikey
 */

import { randomBytes, createHash } from 'crypto'

export interface ApiKey {
  id: string
  name: string
  keyHash: string
  prefix: string
  userId: string
  scopes: string[]
  expiresAt?: Date
  lastUsedAt?: Date
  createdAt: Date
}

export interface ApiKeyStore {
  get(keyHash: string): Promise<ApiKey | null>
  getByPrefix(prefix: string): Promise<ApiKey | null>
  set(apiKey: ApiKey): Promise<void>
  delete(id: string): Promise<void>
  updateLastUsed(id: string): Promise<void>
}

class MemoryStore implements ApiKeyStore {
  private keys = new Map<string, ApiKey>()
  private prefixIndex = new Map<string, string>()

  async get(keyHash: string): Promise<ApiKey | null> {
    return this.keys.get(keyHash) || null
  }

  async getByPrefix(prefix: string): Promise<ApiKey | null> {
    const keyHash = this.prefixIndex.get(prefix)
    if (!keyHash) return null
    return this.keys.get(keyHash) || null
  }

  async set(apiKey: ApiKey): Promise<void> {
    this.keys.set(apiKey.keyHash, apiKey)
    this.prefixIndex.set(apiKey.prefix, apiKey.keyHash)
  }

  async delete(id: string): Promise<void> {
    for (const [hash, key] of this.keys) {
      if (key.id === id) {
        this.keys.delete(hash)
        this.prefixIndex.delete(key.prefix)
        break
      }
    }
  }

  async updateLastUsed(id: string): Promise<void> {
    for (const key of this.keys.values()) {
      if (key.id === id) {
        key.lastUsedAt = new Date()
        break
      }
    }
  }
}

export interface ApiKeyConfig {
  store: ApiKeyStore
  prefix: string
  headerName: string
  queryParam: string
  hashAlgorithm: 'sha256' | 'sha512'
}

const defaultConfig: ApiKeyConfig = {
  store: new MemoryStore(),
  prefix: '${options.prefix || 'og_'}',
  headerName: '${options.headerName || 'X-API-Key'}',
  queryParam: '${options.queryParam || 'api_key'}',
  hashAlgorithm: '${options.hashAlgorithm || 'sha256'}',
}

export class ApiKeyService {
  private config: ApiKeyConfig

  constructor(config: Partial<ApiKeyConfig> = {}) {
    this.config = { ...defaultConfig, ...config }
  }

  generate(): { key: string; hash: string; displayPrefix: string } {
    const randomPart = randomBytes(24).toString('base64url')
    const key = \`\${this.config.prefix}\${randomPart}\`
    const hash = this.hash(key)
    const displayPrefix = key.substring(0, this.config.prefix.length + 8)
    return { key, hash, displayPrefix }
  }

  hash(key: string): string {
    return createHash(this.config.hashAlgorithm).update(key).digest('hex')
  }

  async create(userId: string, name: string, scopes: string[] = [], expiresAt?: Date): Promise<{ apiKey: ApiKey; rawKey: string }> {
    const { key, hash, displayPrefix } = this.generate()

    const apiKey: ApiKey = {
      id: randomBytes(16).toString('hex'),
      name,
      keyHash: hash,
      prefix: displayPrefix,
      userId,
      scopes,
      expiresAt,
      createdAt: new Date(),
    }

    await this.config.store.set(apiKey)
    return { apiKey, rawKey: key }
  }

  async validate(key: string): Promise<ApiKey | null> {
    if (!key.startsWith(this.config.prefix)) return null

    const hash = this.hash(key)
    const apiKey = await this.config.store.get(hash)

    if (!apiKey) return null
    if (apiKey.expiresAt && apiKey.expiresAt < new Date()) return null

    await this.config.store.updateLastUsed(apiKey.id)
    return apiKey
  }

  async revoke(id: string): Promise<void> {
    await this.config.store.delete(id)
  }

  extractFromRequest(headers: Record<string, string | undefined>, query: Record<string, string | undefined>): string | null {
    return headers[this.config.headerName.toLowerCase()]
      || headers[this.config.headerName]
      || query[this.config.queryParam]
      || null
  }

  hasScope(apiKey: ApiKey, requiredScope: string): boolean {
    if (apiKey.scopes.includes('*')) return true
    return apiKey.scopes.includes(requiredScope)
  }
}

export const apiKeyService = new ApiKeyService()
`
}

function generateIndex(): string {
  return `export { ApiKeyService, apiKeyService, type ApiKey, type ApiKeyStore, type ApiKeyConfig } from './apikey-service'
`
}

export function createApiKeyAuth(options: ApiKeyOptions = {}): AuthPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/auth-apikey',
    version: '1.0.0',
    strategy: 'apikey',

    async generate(_schema: SchemaIR, _options: AuthOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions, ...(_options as unknown as ApiKeyOptions) }
      const files: GeneratedFile[] = []

      files.push({ path: 'apikey-service.ts', content: generateApiKeyService(opts), type: 'source' })
      files.push({ path: 'index.ts', content: generateIndex(), type: 'source' })

      return {
        files,
        dependencies: [],
        metadata: { auth: '@opengenerator/auth-apikey', version: '1.0.0', options: opts },
      }
    },

    getMiddleware(): MiddlewareDefinition[] {
      return []
    },

    getDependencies(): Dependency[] {
      return []
    },
  }
}

export const apiKeyAuth = createApiKeyAuth()
export default apiKeyAuth
