/**
 * @opengenerator/auth-magic-link
 *
 * Magic link (passwordless) authentication plugin for OpenGenerator.
 */

import type {
  AuthPlugin,
  AuthOptions,
  GeneratedCode,
  GeneratedFile,
  SchemaIR,
  Dependency,
  MiddlewareDefinition,
} from '@opengenerator/core'

export interface MagicLinkOptions {
  expiresIn?: number
  tokenLength?: number
  baseUrl?: string
  path?: string
}

const DEFAULT_OPTIONS: MagicLinkOptions = {
  expiresIn: 900000, // 15 minutes
  tokenLength: 32,
  baseUrl: 'http://localhost:3000',
  path: '/auth/verify',
}

function generateMagicLinkService(options: MagicLinkOptions): string {
  return `/**
 * Magic Link Service
 * Auto-generated by @opengenerator/auth-magic-link
 */

import { randomBytes, createHash } from 'crypto'

export interface MagicLink {
  id: string
  email: string
  token: string
  tokenHash: string
  expiresAt: Date
  usedAt?: Date
  createdAt: Date
}

export interface MagicLinkStore {
  get(tokenHash: string): Promise<MagicLink | null>
  set(link: MagicLink): Promise<void>
  markUsed(tokenHash: string): Promise<void>
  deleteExpired(): Promise<void>
}

class MemoryStore implements MagicLinkStore {
  private links = new Map<string, MagicLink>()

  async get(tokenHash: string): Promise<MagicLink | null> {
    return this.links.get(tokenHash) || null
  }

  async set(link: MagicLink): Promise<void> {
    this.links.set(link.tokenHash, link)
  }

  async markUsed(tokenHash: string): Promise<void> {
    const link = this.links.get(tokenHash)
    if (link) link.usedAt = new Date()
  }

  async deleteExpired(): Promise<void> {
    const now = new Date()
    for (const [hash, link] of this.links) {
      if (link.expiresAt < now || link.usedAt) {
        this.links.delete(hash)
      }
    }
  }
}

export interface MagicLinkConfig {
  store: MagicLinkStore
  expiresIn: number
  tokenLength: number
  baseUrl: string
  path: string
  sendEmail: (email: string, link: string) => Promise<void>
}

const defaultConfig: Omit<MagicLinkConfig, 'sendEmail'> = {
  store: new MemoryStore(),
  expiresIn: ${options.expiresIn || 900000},
  tokenLength: ${options.tokenLength || 32},
  baseUrl: '${options.baseUrl || 'http://localhost:3000'}',
  path: '${options.path || '/auth/verify'}',
}

export class MagicLinkService {
  private config: MagicLinkConfig

  constructor(config: Partial<MagicLinkConfig> & { sendEmail: MagicLinkConfig['sendEmail'] }) {
    this.config = { ...defaultConfig, ...config }
  }

  private generateToken(): string {
    return randomBytes(this.config.tokenLength).toString('base64url')
  }

  private hashToken(token: string): string {
    return createHash('sha256').update(token).digest('hex')
  }

  async create(email: string): Promise<{ link: MagicLink; url: string }> {
    // Clean up expired links
    await this.config.store.deleteExpired()

    const token = this.generateToken()
    const tokenHash = this.hashToken(token)

    const link: MagicLink = {
      id: randomBytes(16).toString('hex'),
      email,
      token,
      tokenHash,
      expiresAt: new Date(Date.now() + this.config.expiresIn),
      createdAt: new Date(),
    }

    await this.config.store.set(link)

    const url = \`\${this.config.baseUrl}\${this.config.path}?token=\${token}\`
    return { link, url }
  }

  async send(email: string): Promise<void> {
    const { url } = await this.create(email)
    await this.config.sendEmail(email, url)
  }

  async verify(token: string): Promise<{ email: string } | null> {
    const tokenHash = this.hashToken(token)
    const link = await this.config.store.get(tokenHash)

    if (!link) return null
    if (link.usedAt) return null
    if (link.expiresAt < new Date()) return null

    await this.config.store.markUsed(tokenHash)
    return { email: link.email }
  }
}

export function createMagicLinkService(
  sendEmail: (email: string, link: string) => Promise<void>,
  config: Partial<Omit<MagicLinkConfig, 'sendEmail'>> = {}
): MagicLinkService {
  return new MagicLinkService({ ...config, sendEmail })
}
`
}

function generateIndex(): string {
  return `export { MagicLinkService, createMagicLinkService, type MagicLink, type MagicLinkStore, type MagicLinkConfig } from './magic-link-service'
`
}

export function createMagicLinkAuth(options: MagicLinkOptions = {}): AuthPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/auth-magic-link',
    version: '1.0.0',
    strategy: 'magic-link',

    async generate(_schema: SchemaIR, _options: AuthOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions, ...(_options as unknown as MagicLinkOptions) }
      const files: GeneratedFile[] = []

      files.push({ path: 'magic-link-service.ts', content: generateMagicLinkService(opts), type: 'source' })
      files.push({ path: 'index.ts', content: generateIndex(), type: 'source' })

      return {
        files,
        dependencies: [],
        metadata: { auth: '@opengenerator/auth-magic-link', version: '1.0.0', options: opts },
      }
    },

    getMiddleware(): MiddlewareDefinition[] {
      return []
    },

    getDependencies(): Dependency[] {
      return []
    },
  }
}

export const magicLinkAuth = createMagicLinkAuth()
export default magicLinkAuth
