/**
 * @opengenerator/auth-oauth
 *
 * OAuth 2.0 authentication plugin for OpenGenerator.
 */

import type {
  AuthPlugin,
  AuthOptions,
  GeneratedCode,
  GeneratedFile,
  SchemaIR,
  Dependency,
  MiddlewareDefinition,
} from '@opengenerator/core'

export interface OAuthProvider {
  name: string
  clientId: string
  clientSecret: string
  authorizationUrl: string
  tokenUrl: string
  userInfoUrl: string
  scopes: string[]
}

export interface OAuthOptions {
  providers?: Array<'google' | 'github' | 'discord' | 'microsoft' | 'apple'>
  callbackUrl?: string
  stateCookie?: boolean
}

const DEFAULT_OPTIONS: OAuthOptions = {
  providers: ['google', 'github'],
  callbackUrl: '/auth/callback',
  stateCookie: true,
}

const PROVIDER_CONFIGS: Record<string, Omit<OAuthProvider, 'clientId' | 'clientSecret'>> = {
  google: {
    name: 'google',
    authorizationUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenUrl: 'https://oauth2.googleapis.com/token',
    userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
    scopes: ['openid', 'email', 'profile'],
  },
  github: {
    name: 'github',
    authorizationUrl: 'https://github.com/login/oauth/authorize',
    tokenUrl: 'https://github.com/login/oauth/access_token',
    userInfoUrl: 'https://api.github.com/user',
    scopes: ['read:user', 'user:email'],
  },
  discord: {
    name: 'discord',
    authorizationUrl: 'https://discord.com/api/oauth2/authorize',
    tokenUrl: 'https://discord.com/api/oauth2/token',
    userInfoUrl: 'https://discord.com/api/users/@me',
    scopes: ['identify', 'email'],
  },
  microsoft: {
    name: 'microsoft',
    authorizationUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',
    tokenUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/token',
    userInfoUrl: 'https://graph.microsoft.com/v1.0/me',
    scopes: ['openid', 'email', 'profile'],
  },
  apple: {
    name: 'apple',
    authorizationUrl: 'https://appleid.apple.com/auth/authorize',
    tokenUrl: 'https://appleid.apple.com/auth/token',
    userInfoUrl: '',
    scopes: ['name', 'email'],
  },
}

function generateOAuthService(options: OAuthOptions): string {
  const providers = options.providers || ['google', 'github']

  return `/**
 * OAuth 2.0 Service
 * Auto-generated by @opengenerator/auth-oauth
 */

export interface OAuthConfig {
  clientId: string
  clientSecret: string
  redirectUri: string
}

export interface OAuthUser {
  id: string
  email: string
  name?: string
  avatar?: string
  provider: string
  raw: Record<string, unknown>
}

export interface OAuthTokens {
  accessToken: string
  refreshToken?: string
  expiresIn?: number
  tokenType: string
}

const providerConfigs = ${JSON.stringify(
    providers.reduce(
      (acc, p) => ({ ...acc, [p]: PROVIDER_CONFIGS[p] }),
      {}
    ),
    null,
    2
  )}

export class OAuthService {
  private configs: Record<string, OAuthConfig> = {}

  configure(provider: string, config: OAuthConfig) {
    this.configs[provider] = config
  }

  getAuthorizationUrl(provider: string, state?: string): string {
    const config = this.configs[provider]
    const providerConfig = providerConfigs[provider as keyof typeof providerConfigs]
    if (!config || !providerConfig) throw new Error(\`Provider \${provider} not configured\`)

    const params = new URLSearchParams({
      client_id: config.clientId,
      redirect_uri: config.redirectUri,
      response_type: 'code',
      scope: providerConfig.scopes.join(' '),
      ...(state && { state }),
    })

    return \`\${providerConfig.authorizationUrl}?\${params}\`
  }

  async exchangeCode(provider: string, code: string): Promise<OAuthTokens> {
    const config = this.configs[provider]
    const providerConfig = providerConfigs[provider as keyof typeof providerConfigs]
    if (!config || !providerConfig) throw new Error(\`Provider \${provider} not configured\`)

    const response = await fetch(providerConfig.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Accept: 'application/json',
      },
      body: new URLSearchParams({
        client_id: config.clientId,
        client_secret: config.clientSecret,
        code,
        redirect_uri: config.redirectUri,
        grant_type: 'authorization_code',
      }),
    })

    const data = await response.json()
    if (!response.ok) throw new Error(data.error_description || 'Token exchange failed')

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      tokenType: data.token_type || 'Bearer',
    }
  }

  async getUser(provider: string, accessToken: string): Promise<OAuthUser> {
    const providerConfig = providerConfigs[provider as keyof typeof providerConfigs]
    if (!providerConfig) throw new Error(\`Provider \${provider} not configured\`)

    const response = await fetch(providerConfig.userInfoUrl, {
      headers: { Authorization: \`Bearer \${accessToken}\` },
    })

    const data = await response.json()
    if (!response.ok) throw new Error('Failed to fetch user info')

    return this.normalizeUser(provider, data)
  }

  private normalizeUser(provider: string, data: Record<string, unknown>): OAuthUser {
    switch (provider) {
      case 'google':
        return {
          id: data.id as string,
          email: data.email as string,
          name: data.name as string,
          avatar: data.picture as string,
          provider,
          raw: data,
        }
      case 'github':
        return {
          id: String(data.id),
          email: data.email as string,
          name: data.name as string || data.login as string,
          avatar: data.avatar_url as string,
          provider,
          raw: data,
        }
      case 'discord':
        return {
          id: data.id as string,
          email: data.email as string,
          name: data.username as string,
          avatar: data.avatar ? \`https://cdn.discordapp.com/avatars/\${data.id}/\${data.avatar}.png\` : undefined,
          provider,
          raw: data,
        }
      default:
        return {
          id: (data.id || data.sub) as string,
          email: data.email as string,
          name: data.name as string,
          provider,
          raw: data,
        }
    }
  }
}

export const oauthService = new OAuthService()
`
}

function generateIndex(): string {
  return `export { OAuthService, oauthService, type OAuthConfig, type OAuthUser, type OAuthTokens } from './oauth-service'
`
}

export function createOAuth(options: OAuthOptions = {}): AuthPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/auth-oauth',
    version: '1.0.0',
    strategy: 'oauth',

    async generate(_schema: SchemaIR, _options: AuthOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions, ...(_options as unknown as OAuthOptions) }
      const files: GeneratedFile[] = []

      files.push({ path: 'oauth-service.ts', content: generateOAuthService(opts), type: 'source' })
      files.push({ path: 'index.ts', content: generateIndex(), type: 'source' })

      return {
        files,
        dependencies: [],
        metadata: { auth: '@opengenerator/auth-oauth', version: '1.0.0', options: opts },
      }
    },

    getMiddleware(): MiddlewareDefinition[] {
      return []
    },

    getDependencies(): Dependency[] {
      return []
    },
  }
}

export const oauthAuth = createOAuth()
export default oauthAuth
