/**
 * @opengenerator/auth-jwt
 *
 * JWT authentication plugin for OpenGenerator.
 */

import type {
  AuthPlugin,
  AuthOptions,
  GeneratedCode,
  GeneratedFile,
  SchemaIR,
  Dependency,
  MiddlewareDefinition,
} from '@opengenerator/core'

export interface JWTAuthOptions {
  secret?: string
  algorithm?: 'HS256' | 'HS384' | 'HS512' | 'RS256' | 'RS384' | 'RS512' | 'ES256' | 'ES384' | 'ES512'
  expiresIn?: string
  refreshToken?: boolean
  refreshExpiresIn?: string
  issuer?: string
  audience?: string
}

const DEFAULT_OPTIONS: JWTAuthOptions = {
  algorithm: 'HS256',
  expiresIn: '1h',
  refreshToken: true,
  refreshExpiresIn: '7d',
}

function generateJWTService(options: JWTAuthOptions): string {
  return `/**
 * JWT Authentication Service
 * Auto-generated by @opengenerator/auth-jwt
 */

import * as jose from 'jose'

export interface JWTPayload {
  sub: string
  email?: string
  role?: string
  [key: string]: unknown
}

export interface TokenPair {
  accessToken: string
  refreshToken?: string
  expiresIn: number
}

export interface JWTConfig {
  secret: string
  algorithm: string
  expiresIn: string
  refreshExpiresIn: string
  issuer?: string
  audience?: string
}

const defaultConfig: JWTConfig = {
  secret: process.env.JWT_SECRET || 'change-this-secret',
  algorithm: '${options.algorithm || 'HS256'}',
  expiresIn: '${options.expiresIn || '1h'}',
  refreshExpiresIn: '${options.refreshExpiresIn || '7d'}',
  ${options.issuer ? `issuer: '${options.issuer}',` : ''}
  ${options.audience ? `audience: '${options.audience}',` : ''}
}

function parseExpiry(expiry: string): number {
  const match = expiry.match(/^(\\d+)([smhd])$/)
  if (!match) return 3600
  const [, value, unit] = match
  const multipliers: Record<string, number> = { s: 1, m: 60, h: 3600, d: 86400 }
  return parseInt(value) * multipliers[unit]
}

export class JWTService {
  private secret: Uint8Array
  private config: JWTConfig

  constructor(config: Partial<JWTConfig> = {}) {
    this.config = { ...defaultConfig, ...config }
    this.secret = new TextEncoder().encode(this.config.secret)
  }

  async sign(payload: JWTPayload): Promise<TokenPair> {
    const expiresInSeconds = parseExpiry(this.config.expiresIn)

    const jwt = new jose.SignJWT(payload as jose.JWTPayload)
      .setProtectedHeader({ alg: this.config.algorithm })
      .setIssuedAt()
      .setExpirationTime(this.config.expiresIn)

    if (this.config.issuer) jwt.setIssuer(this.config.issuer)
    if (this.config.audience) jwt.setAudience(this.config.audience)

    const accessToken = await jwt.sign(this.secret)

    const result: TokenPair = {
      accessToken,
      expiresIn: expiresInSeconds,
    }

    ${
      options.refreshToken
        ? `
    // Generate refresh token
    const refreshJwt = new jose.SignJWT({ sub: payload.sub, type: 'refresh' } as jose.JWTPayload)
      .setProtectedHeader({ alg: this.config.algorithm })
      .setIssuedAt()
      .setExpirationTime(this.config.refreshExpiresIn)

    if (this.config.issuer) refreshJwt.setIssuer(this.config.issuer)

    result.refreshToken = await refreshJwt.sign(this.secret)
    `
        : ''
    }

    return result
  }

  async verify(token: string): Promise<JWTPayload> {
    try {
      const options: jose.JWTVerifyOptions = {}
      if (this.config.issuer) options.issuer = this.config.issuer
      if (this.config.audience) options.audience = this.config.audience

      const { payload } = await jose.jwtVerify(token, this.secret, options)
      return payload as unknown as JWTPayload
    } catch (error) {
      throw new Error('Invalid token')
    }
  }

  async refresh(refreshToken: string): Promise<TokenPair> {
    const payload = await this.verify(refreshToken)
    if ((payload as any).type !== 'refresh') {
      throw new Error('Invalid refresh token')
    }
    return this.sign({ sub: payload.sub })
  }

  decode(token: string): JWTPayload | null {
    try {
      return jose.decodeJwt(token) as unknown as JWTPayload
    } catch {
      return null
    }
  }
}

export const jwtService = new JWTService()
`
}

function generateMiddleware(): string {
  return `/**
 * JWT Authentication Middleware
 */

import { JWTService, JWTPayload } from './jwt-service'

export interface AuthRequest {
  user?: JWTPayload
  token?: string
}

export function extractToken(authHeader?: string): string | null {
  if (!authHeader) return null
  const [type, token] = authHeader.split(' ')
  if (type !== 'Bearer' || !token) return null
  return token
}

export function createAuthMiddleware(jwtService: JWTService) {
  return async (req: AuthRequest, authHeader?: string): Promise<JWTPayload | null> => {
    const token = extractToken(authHeader)
    if (!token) return null

    try {
      const payload = await jwtService.verify(token)
      req.user = payload
      req.token = token
      return payload
    } catch {
      return null
    }
  }
}

export function requireAuth(jwtService: JWTService) {
  return async (req: AuthRequest, authHeader?: string): Promise<JWTPayload> => {
    const payload = await createAuthMiddleware(jwtService)(req, authHeader)
    if (!payload) {
      throw new Error('Unauthorized')
    }
    return payload
  }
}
`
}

function generateIndex(): string {
  return `export { JWTService, jwtService, type JWTPayload, type TokenPair, type JWTConfig } from './jwt-service'
export { createAuthMiddleware, requireAuth, extractToken, type AuthRequest } from './middleware'
`
}

export function createJWTAuth(options: JWTAuthOptions = {}): AuthPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/auth-jwt',
    version: '1.0.0',
    strategy: 'jwt',

    async generate(_schema: SchemaIR, _options: AuthOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions, ...(_options as unknown as JWTAuthOptions) }
      const files: GeneratedFile[] = []
      const dependencies: Dependency[] = []

      files.push({ path: 'jwt-service.ts', content: generateJWTService(opts), type: 'source' })
      files.push({ path: 'middleware.ts', content: generateMiddleware(), type: 'source' })
      files.push({ path: 'index.ts', content: generateIndex(), type: 'source' })

      dependencies.push({ name: 'jose', version: '^5.2.0', dev: false })

      return {
        files,
        dependencies,
        metadata: { auth: '@opengenerator/auth-jwt', version: '1.0.0', options: opts },
      }
    },

    getMiddleware(): MiddlewareDefinition[] {
      return []
    },

    getDependencies(): Dependency[] {
      return [{ name: 'jose', version: '^5.2.0', dev: false }]
    },
  }
}

export const jwtAuth = createJWTAuth()
export default jwtAuth
