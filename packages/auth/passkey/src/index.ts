/**
 * @opengenerator/auth-passkey
 *
 * Passkey/WebAuthn authentication plugin for OpenGenerator.
 */

import type {
  AuthPlugin,
  AuthOptions,
  GeneratedCode,
  GeneratedFile,
  SchemaIR,
  Dependency,
  MiddlewareDefinition,
} from '@opengenerator/core'

export interface PasskeyOptions {
  rpName?: string
  rpID?: string
  origin?: string
  attestation?: 'none' | 'indirect' | 'direct' | 'enterprise'
  userVerification?: 'required' | 'preferred' | 'discouraged'
}

const DEFAULT_OPTIONS: PasskeyOptions = {
  rpName: 'OpenGenerator App',
  rpID: 'localhost',
  origin: 'http://localhost:3000',
  attestation: 'none',
  userVerification: 'preferred',
}

function generatePasskeyService(options: PasskeyOptions): string {
  return `/**
 * Passkey/WebAuthn Service
 * Auto-generated by @opengenerator/auth-passkey
 */

import {
  generateRegistrationOptions,
  verifyRegistrationResponse,
  generateAuthenticationOptions,
  verifyAuthenticationResponse,
  type VerifiedRegistrationResponse,
  type VerifiedAuthenticationResponse,
} from '@simplewebauthn/server'

export interface Passkey {
  id: string
  credentialID: string
  credentialPublicKey: string
  counter: number
  transports?: string[]
  userId: string
  createdAt: Date
  lastUsedAt?: Date
}

export interface PasskeyStore {
  getByUserId(userId: string): Promise<Passkey[]>
  getByCredentialId(credentialId: string): Promise<Passkey | null>
  save(passkey: Passkey): Promise<void>
  updateCounter(credentialId: string, counter: number): Promise<void>
  delete(id: string): Promise<void>
}

class MemoryStore implements PasskeyStore {
  private passkeys = new Map<string, Passkey>()

  async getByUserId(userId: string): Promise<Passkey[]> {
    return Array.from(this.passkeys.values()).filter(p => p.userId === userId)
  }

  async getByCredentialId(credentialId: string): Promise<Passkey | null> {
    return Array.from(this.passkeys.values()).find(p => p.credentialID === credentialId) || null
  }

  async save(passkey: Passkey): Promise<void> {
    this.passkeys.set(passkey.id, passkey)
  }

  async updateCounter(credentialId: string, counter: number): Promise<void> {
    const passkey = await this.getByCredentialId(credentialId)
    if (passkey) {
      passkey.counter = counter
      passkey.lastUsedAt = new Date()
    }
  }

  async delete(id: string): Promise<void> {
    this.passkeys.delete(id)
  }
}

export interface PasskeyConfig {
  store: PasskeyStore
  rpName: string
  rpID: string
  origin: string
  attestation: 'none' | 'indirect' | 'direct' | 'enterprise'
  userVerification: 'required' | 'preferred' | 'discouraged'
}

const defaultConfig: PasskeyConfig = {
  store: new MemoryStore(),
  rpName: '${options.rpName || 'OpenGenerator App'}',
  rpID: '${options.rpID || 'localhost'}',
  origin: '${options.origin || 'http://localhost:3000'}',
  attestation: '${options.attestation || 'none'}',
  userVerification: '${options.userVerification || 'preferred'}',
}

// Challenge store (in-memory for simplicity)
const challenges = new Map<string, { challenge: string; expiresAt: Date }>()

export class PasskeyService {
  private config: PasskeyConfig

  constructor(config: Partial<PasskeyConfig> = {}) {
    this.config = { ...defaultConfig, ...config }
  }

  async generateRegistrationOptions(userId: string, userName: string, userDisplayName: string) {
    const userPasskeys = await this.config.store.getByUserId(userId)

    const options = await generateRegistrationOptions({
      rpName: this.config.rpName,
      rpID: this.config.rpID,
      userID: new TextEncoder().encode(userId),
      userName,
      userDisplayName,
      attestationType: this.config.attestation,
      excludeCredentials: userPasskeys.map(p => ({
        id: Buffer.from(p.credentialID, 'base64url'),
        transports: p.transports as any,
      })),
      authenticatorSelection: {
        userVerification: this.config.userVerification,
        residentKey: 'preferred',
      },
    })

    // Store challenge
    challenges.set(userId, {
      challenge: options.challenge,
      expiresAt: new Date(Date.now() + 300000), // 5 minutes
    })

    return options
  }

  async verifyRegistration(
    userId: string,
    response: any
  ): Promise<{ verified: boolean; passkey?: Passkey }> {
    const stored = challenges.get(userId)
    if (!stored || stored.expiresAt < new Date()) {
      return { verified: false }
    }

    try {
      const verification = await verifyRegistrationResponse({
        response,
        expectedChallenge: stored.challenge,
        expectedOrigin: this.config.origin,
        expectedRPID: this.config.rpID,
      })

      if (verification.verified && verification.registrationInfo) {
        const { credential } = verification.registrationInfo

        const passkey: Passkey = {
          id: crypto.randomUUID(),
          credentialID: Buffer.from(credential.id).toString('base64url'),
          credentialPublicKey: Buffer.from(credential.publicKey).toString('base64url'),
          counter: credential.counter,
          transports: response.response.transports,
          userId,
          createdAt: new Date(),
        }

        await this.config.store.save(passkey)
        challenges.delete(userId)

        return { verified: true, passkey }
      }

      return { verified: false }
    } catch {
      return { verified: false }
    }
  }

  async generateAuthenticationOptions(userId: string) {
    const userPasskeys = await this.config.store.getByUserId(userId)

    const options = await generateAuthenticationOptions({
      rpID: this.config.rpID,
      allowCredentials: userPasskeys.map(p => ({
        id: Buffer.from(p.credentialID, 'base64url'),
        transports: p.transports as any,
      })),
      userVerification: this.config.userVerification,
    })

    challenges.set(userId, {
      challenge: options.challenge,
      expiresAt: new Date(Date.now() + 300000),
    })

    return options
  }

  async verifyAuthentication(userId: string, response: any): Promise<{ verified: boolean }> {
    const stored = challenges.get(userId)
    if (!stored || stored.expiresAt < new Date()) {
      return { verified: false }
    }

    const credentialId = Buffer.from(response.id, 'base64url').toString('base64url')
    const passkey = await this.config.store.getByCredentialId(credentialId)

    if (!passkey) {
      return { verified: false }
    }

    try {
      const verification = await verifyAuthenticationResponse({
        response,
        expectedChallenge: stored.challenge,
        expectedOrigin: this.config.origin,
        expectedRPID: this.config.rpID,
        credential: {
          id: Buffer.from(passkey.credentialID, 'base64url'),
          publicKey: Buffer.from(passkey.credentialPublicKey, 'base64url'),
          counter: passkey.counter,
        },
      })

      if (verification.verified) {
        await this.config.store.updateCounter(
          passkey.credentialID,
          verification.authenticationInfo.newCounter
        )
        challenges.delete(userId)
        return { verified: true }
      }

      return { verified: false }
    } catch {
      return { verified: false }
    }
  }
}

export const passkeyService = new PasskeyService()
`
}

function generateIndex(): string {
  return `export { PasskeyService, passkeyService, type Passkey, type PasskeyStore, type PasskeyConfig } from './passkey-service'
`
}

export function createPasskeyAuth(options: PasskeyOptions = {}): AuthPlugin {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  return {
    name: '@opengenerator/auth-passkey',
    version: '1.0.0',
    strategy: 'passkey',

    async generate(_schema: SchemaIR, _options: AuthOptions): Promise<GeneratedCode> {
      const opts = { ...mergedOptions, ...(_options as unknown as PasskeyOptions) }
      const files: GeneratedFile[] = []
      const dependencies: Dependency[] = []

      files.push({ path: 'passkey-service.ts', content: generatePasskeyService(opts), type: 'source' })
      files.push({ path: 'index.ts', content: generateIndex(), type: 'source' })

      dependencies.push({ name: '@simplewebauthn/server', version: '^9.0.0', dev: false })

      return {
        files,
        dependencies,
        metadata: { auth: '@opengenerator/auth-passkey', version: '1.0.0', options: opts },
      }
    },

    getMiddleware(): MiddlewareDefinition[] {
      return []
    },

    getDependencies(): Dependency[] {
      return [{ name: '@simplewebauthn/server', version: '^9.0.0', dev: false }]
    },
  }
}

export const passkeyAuth = createPasskeyAuth()
export default passkeyAuth
