/**
 * {{pascalCase name}} Service Tests
 * Generated by OpenGenerator
 */

import { describe, it, expect, beforeEach, vi } from 'vitest'
import { {{pascalCase name}}Service } from '../src/{{kebabCase name}}/{{kebabCase name}}.service'

// Mock repository
vi.mock('../src/{{kebabCase name}}/{{kebabCase name}}.repository', () => ({
  {{camelCase name}}Repository: {
    findMany: vi.fn(),
    findUnique: vi.fn(),
    findFirst: vi.fn(),
    count: vi.fn(),
    create: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
  },
}))

import { {{camelCase name}}Repository } from '../src/{{kebabCase name}}/{{kebabCase name}}.repository'

describe('{{pascalCase name}}Service', () => {
  let service: {{pascalCase name}}Service

  const mock{{pascalCase name}} = {
    id: 'test-id-1',
{{#each fields}}
    {{name}}: {{mockValue type}},
{{/each}}
    createdAt: new Date(),
    updatedAt: new Date(),
  }

  beforeEach(() => {
    service = new {{pascalCase name}}Service()
    vi.clearAllMocks()
  })

  describe('findAll', () => {
    it('should return paginated results', async () => {
      const mockData = [mock{{pascalCase name}}]
      vi.mocked({{camelCase name}}Repository.findMany).mockResolvedValue(mockData)
      vi.mocked({{camelCase name}}Repository.count).mockResolvedValue(1)

      const result = await service.findAll({
        page: 1,
        limit: 10,
      })

      expect(result.data).toEqual(mockData)
      expect(result.total).toBe(1)
      expect(result.page).toBe(1)
      expect(result.limit).toBe(10)
      expect(result.totalPages).toBe(1)
    })

    it('should apply filters correctly', async () => {
      vi.mocked({{camelCase name}}Repository.findMany).mockResolvedValue([])
      vi.mocked({{camelCase name}}Repository.count).mockResolvedValue(0)

      await service.findAll({
        page: 1,
        limit: 10,
        filters: { search: 'test' },
      })

      expect({{camelCase name}}Repository.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.any(Object),
        })
      )
    })

    it('should handle sorting', async () => {
      vi.mocked({{camelCase name}}Repository.findMany).mockResolvedValue([])
      vi.mocked({{camelCase name}}Repository.count).mockResolvedValue(0)

      await service.findAll({
        page: 1,
        limit: 10,
        sort: 'createdAt',
        order: 'desc',
      })

      expect({{camelCase name}}Repository.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          orderBy: { createdAt: 'desc' },
        })
      )
    })
  })

  describe('findById', () => {
    it('should return {{lowerCase name}} by id', async () => {
      vi.mocked({{camelCase name}}Repository.findUnique).mockResolvedValue(mock{{pascalCase name}})

      const result = await service.findById('test-id-1')

      expect(result).toEqual(mock{{pascalCase name}})
      expect({{camelCase name}}Repository.findUnique).toHaveBeenCalledWith({
        where: { id: 'test-id-1' },
      })
    })

    it('should return null if not found', async () => {
      vi.mocked({{camelCase name}}Repository.findUnique).mockResolvedValue(null)

      const result = await service.findById('non-existent')

      expect(result).toBeNull()
    })
  })

  describe('create', () => {
    it('should create new {{lowerCase name}}', async () => {
      const input = {
{{#each fields}}
{{#unless isGenerated}}
        {{name}}: {{mockValue type}},
{{/unless}}
{{/each}}
      }

      vi.mocked({{camelCase name}}Repository.create).mockResolvedValue({
        ...mock{{pascalCase name}},
        ...input,
      })

      const result = await service.create(input)

      expect(result).toBeDefined()
      expect({{camelCase name}}Repository.create).toHaveBeenCalledWith({
        data: expect.objectContaining(input),
      })
    })
  })

  describe('update', () => {
    it('should update existing {{lowerCase name}}', async () => {
      const input = {
{{#each fields}}
{{#unless isGenerated}}
        {{name}}: {{mockValue type}},
{{/unless}}
{{/each}}
      }

      vi.mocked({{camelCase name}}Repository.findUnique).mockResolvedValue(mock{{pascalCase name}})
      vi.mocked({{camelCase name}}Repository.update).mockResolvedValue({
        ...mock{{pascalCase name}},
        ...input,
      })

      const result = await service.update('test-id-1', input)

      expect(result).toBeDefined()
      expect({{camelCase name}}Repository.update).toHaveBeenCalled()
    })

    it('should return null if {{lowerCase name}} not found', async () => {
      vi.mocked({{camelCase name}}Repository.findUnique).mockResolvedValue(null)

      const result = await service.update('non-existent', {})

      expect(result).toBeNull()
      expect({{camelCase name}}Repository.update).not.toHaveBeenCalled()
    })
  })

  describe('delete', () => {
    it('should delete existing {{lowerCase name}}', async () => {
      vi.mocked({{camelCase name}}Repository.findUnique).mockResolvedValue(mock{{pascalCase name}})
      vi.mocked({{camelCase name}}Repository.delete).mockResolvedValue(undefined)

      const result = await service.delete('test-id-1')

      expect(result).toBe(true)
      expect({{camelCase name}}Repository.delete).toHaveBeenCalledWith({
        where: { id: 'test-id-1' },
      })
    })

    it('should return false if {{lowerCase name}} not found', async () => {
      vi.mocked({{camelCase name}}Repository.findUnique).mockResolvedValue(null)

      const result = await service.delete('non-existent')

      expect(result).toBe(false)
      expect({{camelCase name}}Repository.delete).not.toHaveBeenCalled()
    })
  })
})
