/**
 * {{pascalCase name}} GraphQL Resolvers
 * Generated by OpenGenerator
 */

import type { GraphQLResolveInfo } from 'graphql'
import type { Context } from '../context'
import { {{pascalCase name}}Service } from './{{kebabCase name}}.service'
import { {{pascalCase name}}DataLoader } from './{{kebabCase name}}.dataloader'
{{#if subscriptions}}
import { pubsub, {{constantCase name}}_EVENTS } from '../pubsub'
{{/if}}

const service = new {{pascalCase name}}Service()

export const {{camelCase name}}Resolvers = {
  Query: {
    {{camelCase name}}: async (
      _parent: unknown,
      args: { id: string },
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if auth}}
      context.requireAuth()
      {{/if}}
      return service.findById(args.id)
    },

    {{pluralize (camelCase name)}}: async (
      _parent: unknown,
      args: {
        first?: number
        after?: string
        last?: number
        before?: string
        filter?: Record<string, unknown>
        orderBy?: Record<string, 'asc' | 'desc'>
      },
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if auth}}
      context.requireAuth()
      {{/if}}

      const { first = 10, after, filter, orderBy } = args
      const cursor = after ? decodeCursor(after) : undefined

      const result = await service.findAll({
        limit: first + 1,
        cursor,
        filters: filter || {},
        sort: orderBy ? Object.keys(orderBy)[0] : undefined,
        order: orderBy ? Object.values(orderBy)[0] : undefined,
      })

      const hasNextPage = result.data.length > first
      const edges = result.data.slice(0, first).map((node) => ({
        node,
        cursor: encodeCursor(node.id),
      }))

      return {
        edges,
        pageInfo: {
          hasNextPage,
          hasPreviousPage: !!after,
          startCursor: edges[0]?.cursor,
          endCursor: edges[edges.length - 1]?.cursor,
        },
        totalCount: result.total,
      }
    },

    {{camelCase name}}Count: async (
      _parent: unknown,
      args: { filter?: Record<string, unknown> },
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if auth}}
      context.requireAuth()
      {{/if}}
      return service.count(args.filter || {})
    },
  },

  Mutation: {
    create{{pascalCase name}}: async (
      _parent: unknown,
      args: { input: Record<string, unknown> },
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if auth}}
      context.requireAuth()
      {{/if}}

      const result = await service.create(args.input)

      {{#if subscriptions}}
      pubsub.publish({{constantCase name}}_EVENTS.CREATED, {
        {{camelCase name}}Created: result,
      })
      {{/if}}

      return result
    },

    update{{pascalCase name}}: async (
      _parent: unknown,
      args: { id: string; input: Record<string, unknown> },
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if auth}}
      context.requireAuth()
      {{/if}}

      const result = await service.update(args.id, args.input)

      {{#if subscriptions}}
      if (result) {
        pubsub.publish({{constantCase name}}_EVENTS.UPDATED, {
          {{camelCase name}}Updated: result,
        })
      }
      {{/if}}

      return result
    },

    delete{{pascalCase name}}: async (
      _parent: unknown,
      args: { id: string },
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if auth}}
      context.requireAuth()
      {{/if}}

      const deleted = await service.delete(args.id)

      {{#if subscriptions}}
      if (deleted) {
        pubsub.publish({{constantCase name}}_EVENTS.DELETED, {
          {{camelCase name}}Deleted: args.id,
        })
      }
      {{/if}}

      return deleted
    },

    deleteMany{{pluralize (pascalCase name)}}: async (
      _parent: unknown,
      args: { ids: string[] },
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if auth}}
      context.requireAuth()
      {{/if}}
      return service.deleteMany(args.ids)
    },
  },

  {{#if subscriptions}}
  Subscription: {
    {{camelCase name}}Created: {
      subscribe: () => pubsub.asyncIterableIterator([{{constantCase name}}_EVENTS.CREATED]),
    },

    {{camelCase name}}Updated: {
      subscribe: (_parent: unknown, args: { id?: string }) => {
        const iterator = pubsub.asyncIterableIterator([{{constantCase name}}_EVENTS.UPDATED])

        if (args.id) {
          return {
            async *[Symbol.asyncIterator]() {
              for await (const payload of iterator) {
                if (payload.{{camelCase name}}Updated.id === args.id) {
                  yield payload
                }
              }
            },
          }
        }

        return iterator
      },
    },

    {{camelCase name}}Deleted: {
      subscribe: () => pubsub.asyncIterableIterator([{{constantCase name}}_EVENTS.DELETED]),
    },
  },
  {{/if}}

  {{pascalCase name}}: {
    {{#each relations}}
    {{name}}: async (
      parent: { {{../foreignKey}}: string },
      _args: unknown,
      context: Context,
      _info: GraphQLResolveInfo
    ) => {
      {{#if isArray}}
      return context.dataloaders.{{camelCase ../name}}{{pascalCase name}}.load(parent.id)
      {{else}}
      return context.dataloaders.{{camelCase type}}.load(parent.{{../foreignKey}})
      {{/if}}
    },
    {{/each}}
  },
}

function encodeCursor(id: string): string {
  return Buffer.from(id).toString('base64')
}

function decodeCursor(cursor: string): string {
  return Buffer.from(cursor, 'base64').toString('utf-8')
}
