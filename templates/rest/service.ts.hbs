/**
 * {{pascalCase name}} Service
 * Generated by OpenGenerator
 */

import type { {{pascalCase name}}, Create{{pascalCase name}}Input, Update{{pascalCase name}}Input } from './{{kebabCase name}}.types'
import type { PaginatedResult, FindAllOptions } from '../types/common'
import { {{camelCase name}}Repository } from './{{kebabCase name}}.repository'

export class {{pascalCase name}}Service {
  private readonly repository = new {{camelCase name}}Repository()

  /**
   * Find all {{pluralize (lowerCase name)}} with pagination
   */
  async findAll(options: FindAllOptions): Promise<PaginatedResult<{{pascalCase name}}>> {
    const { page = 1, limit = 10, sort, order = 'asc', filters = {} } = options

    const skip = (page - 1) * limit
    const [data, total] = await Promise.all([
      this.repository.findMany({
        skip,
        take: limit,
        orderBy: sort ? { [sort]: order } : undefined,
        where: this.buildWhereClause(filters),
      }),
      this.repository.count({
        where: this.buildWhereClause(filters),
      }),
    ])

    return {
      data,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    }
  }

  /**
   * Find {{lowerCase name}} by ID
   */
  async findById(id: string): Promise<{{pascalCase name}} | null> {
    return this.repository.findUnique({ where: { id } })
  }

  /**
   * Find {{lowerCase name}} by unique field
   */
  async findBy(field: keyof {{pascalCase name}}, value: unknown): Promise<{{pascalCase name}} | null> {
    return this.repository.findFirst({ where: { [field]: value } })
  }

  /**
   * Create new {{lowerCase name}}
   */
  async create(input: Create{{pascalCase name}}Input): Promise<{{pascalCase name}}> {
    {{#if hooks.beforeCreate}}
    await this.beforeCreate(input)
    {{/if}}

    const result = await this.repository.create({
      data: {
        ...input,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    })

    {{#if hooks.afterCreate}}
    await this.afterCreate(result)
    {{/if}}

    return result
  }

  /**
   * Update {{lowerCase name}}
   */
  async update(id: string, input: Update{{pascalCase name}}Input): Promise<{{pascalCase name}} | null> {
    const existing = await this.findById(id)
    if (!existing) return null

    {{#if hooks.beforeUpdate}}
    await this.beforeUpdate(existing, input)
    {{/if}}

    const result = await this.repository.update({
      where: { id },
      data: {
        ...input,
        updatedAt: new Date(),
      },
    })

    {{#if hooks.afterUpdate}}
    await this.afterUpdate(result)
    {{/if}}

    return result
  }

  /**
   * Delete {{lowerCase name}}
   */
  async delete(id: string): Promise<boolean> {
    const existing = await this.findById(id)
    if (!existing) return false

    {{#if hooks.beforeDelete}}
    await this.beforeDelete(existing)
    {{/if}}

    {{#if softDelete}}
    await this.repository.update({
      where: { id },
      data: { deletedAt: new Date() },
    })
    {{else}}
    await this.repository.delete({ where: { id } })
    {{/if}}

    {{#if hooks.afterDelete}}
    await this.afterDelete(existing)
    {{/if}}

    return true
  }

  /**
   * Build where clause from filters
   */
  private buildWhereClause(filters: Record<string, unknown>): Record<string, unknown> {
    const where: Record<string, unknown> = {}

    for (const [key, value] of Object.entries(filters)) {
      if (value === undefined || value === null || value === '') continue

      // Handle search
      if (key === 'search' && typeof value === 'string') {
        where.OR = [
          {{#each searchFields}}
          { {{this}}: { contains: value, mode: 'insensitive' } },
          {{/each}}
        ]
        continue
      }

      // Handle date ranges
      if (key.endsWith('_from')) {
        const field = key.replace('_from', '')
        where[field] = { ...((where[field] as object) || {}), gte: new Date(value as string) }
        continue
      }
      if (key.endsWith('_to')) {
        const field = key.replace('_to', '')
        where[field] = { ...((where[field] as object) || {}), lte: new Date(value as string) }
        continue
      }

      // Direct match
      where[key] = value
    }

    {{#if softDelete}}
    where.deletedAt = null
    {{/if}}

    return where
  }

  {{#if hooks.beforeCreate}}
  private async beforeCreate(input: Create{{pascalCase name}}Input): Promise<void> {
    // Hook: before create
  }
  {{/if}}

  {{#if hooks.afterCreate}}
  private async afterCreate(result: {{pascalCase name}}): Promise<void> {
    // Hook: after create
  }
  {{/if}}

  {{#if hooks.beforeUpdate}}
  private async beforeUpdate(existing: {{pascalCase name}}, input: Update{{pascalCase name}}Input): Promise<void> {
    // Hook: before update
  }
  {{/if}}

  {{#if hooks.afterUpdate}}
  private async afterUpdate(result: {{pascalCase name}}): Promise<void> {
    // Hook: after update
  }
  {{/if}}

  {{#if hooks.beforeDelete}}
  private async beforeDelete(existing: {{pascalCase name}}): Promise<void> {
    // Hook: before delete
  }
  {{/if}}

  {{#if hooks.afterDelete}}
  private async afterDelete(deleted: {{pascalCase name}}): Promise<void> {
    // Hook: after delete
  }
  {{/if}}
}
