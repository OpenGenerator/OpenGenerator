/**
 * {{pascalCase name}} Repository
 * Generated by OpenGenerator
 */

{{#if (eq database 'prisma')}}
import { PrismaClient } from '@prisma/client'
import type { Prisma } from '@prisma/client'

const prisma = new PrismaClient()

export class {{camelCase name}}Repository {
  async findMany(args: Prisma.{{pascalCase name}}FindManyArgs) {
    return prisma.{{camelCase name}}.findMany(args)
  }

  async findUnique(args: Prisma.{{pascalCase name}}FindUniqueArgs) {
    return prisma.{{camelCase name}}.findUnique(args)
  }

  async findFirst(args: Prisma.{{pascalCase name}}FindFirstArgs) {
    return prisma.{{camelCase name}}.findFirst(args)
  }

  async count(args: Prisma.{{pascalCase name}}CountArgs) {
    return prisma.{{camelCase name}}.count(args)
  }

  async create(args: Prisma.{{pascalCase name}}CreateArgs) {
    return prisma.{{camelCase name}}.create(args)
  }

  async update(args: Prisma.{{pascalCase name}}UpdateArgs) {
    return prisma.{{camelCase name}}.update(args)
  }

  async delete(args: Prisma.{{pascalCase name}}DeleteArgs) {
    return prisma.{{camelCase name}}.delete(args)
  }

  async upsert(args: Prisma.{{pascalCase name}}UpsertArgs) {
    return prisma.{{camelCase name}}.upsert(args)
  }

  async createMany(args: Prisma.{{pascalCase name}}CreateManyArgs) {
    return prisma.{{camelCase name}}.createMany(args)
  }

  async updateMany(args: Prisma.{{pascalCase name}}UpdateManyArgs) {
    return prisma.{{camelCase name}}.updateMany(args)
  }

  async deleteMany(args: Prisma.{{pascalCase name}}DeleteManyArgs) {
    return prisma.{{camelCase name}}.deleteMany(args)
  }
}
{{/if}}

{{#if (eq database 'drizzle')}}
import { db } from '../db'
import { {{camelCase name}}s } from '../db/schema'
import { eq, and, or, like, gte, lte, desc, asc, sql } from 'drizzle-orm'

export class {{camelCase name}}Repository {
  async findMany(options: {
    skip?: number
    take?: number
    where?: Record<string, unknown>
    orderBy?: Record<string, 'asc' | 'desc'>
  }) {
    let query = db.select().from({{camelCase name}}s)

    if (options.where) {
      query = query.where(this.buildWhere(options.where))
    }

    if (options.orderBy) {
      const [field, direction] = Object.entries(options.orderBy)[0]
      query = query.orderBy(direction === 'desc' ? desc({{camelCase name}}s[field]) : asc({{camelCase name}}s[field]))
    }

    if (options.skip) {
      query = query.offset(options.skip)
    }

    if (options.take) {
      query = query.limit(options.take)
    }

    return query
  }

  async findUnique(options: { where: { id: string } }) {
    const results = await db.select().from({{camelCase name}}s).where(eq({{camelCase name}}s.id, options.where.id)).limit(1)
    return results[0] || null
  }

  async findFirst(options: { where: Record<string, unknown> }) {
    const results = await db.select().from({{camelCase name}}s).where(this.buildWhere(options.where)).limit(1)
    return results[0] || null
  }

  async count(options: { where?: Record<string, unknown> }) {
    const result = await db.select({ count: sql<number>`count(*)` }).from({{camelCase name}}s).where(options.where ? this.buildWhere(options.where) : undefined)
    return result[0].count
  }

  async create(options: { data: Record<string, unknown> }) {
    const results = await db.insert({{camelCase name}}s).values(options.data).returning()
    return results[0]
  }

  async update(options: { where: { id: string }; data: Record<string, unknown> }) {
    const results = await db.update({{camelCase name}}s).set(options.data).where(eq({{camelCase name}}s.id, options.where.id)).returning()
    return results[0]
  }

  async delete(options: { where: { id: string } }) {
    await db.delete({{camelCase name}}s).where(eq({{camelCase name}}s.id, options.where.id))
  }

  private buildWhere(where: Record<string, unknown>) {
    const conditions = Object.entries(where).map(([key, value]) => {
      if (typeof value === 'object' && value !== null) {
        const ops = value as Record<string, unknown>
        if ('contains' in ops) return like({{camelCase name}}s[key], `%${ops.contains}%`)
        if ('gte' in ops) return gte({{camelCase name}}s[key], ops.gte)
        if ('lte' in ops) return lte({{camelCase name}}s[key], ops.lte)
      }
      return eq({{camelCase name}}s[key], value)
    })
    return and(...conditions)
  }
}
{{/if}}

{{#if (eq database 'raw-sql')}}
import { pool } from '../db'

export class {{camelCase name}}Repository {
  private tableName = '{{snakeCase (pluralize name)}}'

  async findMany(options: {
    skip?: number
    take?: number
    where?: Record<string, unknown>
    orderBy?: Record<string, 'asc' | 'desc'>
  }) {
    const { skip = 0, take = 10, where = {}, orderBy } = options
    const { clause, values } = this.buildWhereClause(where)

    let sql = `SELECT * FROM ${this.tableName}`
    if (clause) sql += ` WHERE ${clause}`
    if (orderBy) {
      const [field, dir] = Object.entries(orderBy)[0]
      sql += ` ORDER BY ${field} ${dir.toUpperCase()}`
    }
    sql += ` LIMIT $${values.length + 1} OFFSET $${values.length + 2}`

    const result = await pool.query(sql, [...values, take, skip])
    return result.rows
  }

  async findUnique(options: { where: { id: string } }) {
    const result = await pool.query(
      `SELECT * FROM ${this.tableName} WHERE id = $1 LIMIT 1`,
      [options.where.id]
    )
    return result.rows[0] || null
  }

  async count(options: { where?: Record<string, unknown> }) {
    const { clause, values } = this.buildWhereClause(options.where || {})
    let sql = `SELECT COUNT(*) as count FROM ${this.tableName}`
    if (clause) sql += ` WHERE ${clause}`
    const result = await pool.query(sql, values)
    return parseInt(result.rows[0].count, 10)
  }

  async create(options: { data: Record<string, unknown> }) {
    const keys = Object.keys(options.data)
    const values = Object.values(options.data)
    const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ')

    const result = await pool.query(
      `INSERT INTO ${this.tableName} (${keys.join(', ')}) VALUES (${placeholders}) RETURNING *`,
      values
    )
    return result.rows[0]
  }

  async update(options: { where: { id: string }; data: Record<string, unknown> }) {
    const keys = Object.keys(options.data)
    const values = Object.values(options.data)
    const setClause = keys.map((k, i) => `${k} = $${i + 1}`).join(', ')

    const result = await pool.query(
      `UPDATE ${this.tableName} SET ${setClause} WHERE id = $${keys.length + 1} RETURNING *`,
      [...values, options.where.id]
    )
    return result.rows[0]
  }

  async delete(options: { where: { id: string } }) {
    await pool.query(`DELETE FROM ${this.tableName} WHERE id = $1`, [options.where.id])
  }

  private buildWhereClause(where: Record<string, unknown>): { clause: string; values: unknown[] } {
    const conditions: string[] = []
    const values: unknown[] = []

    for (const [key, value] of Object.entries(where)) {
      if (value === undefined || value === null) continue
      values.push(value)
      conditions.push(`${key} = $${values.length}`)
    }

    return { clause: conditions.join(' AND '), values }
  }
}
{{/if}}
