/**
 * {{pascalCase name}} tRPC Router
 * Generated by OpenGenerator
 */

import { z } from 'zod'
import { router, {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}} } from '../trpc'
import { {{pascalCase name}}Service } from './{{kebabCase name}}.service'
import { TRPCError } from '@trpc/server'

const service = new {{pascalCase name}}Service()

/**
 * {{pascalCase name}} input schemas
 */
const {{camelCase name}}IdSchema = z.object({
  id: z.string().uuid(),
})

const create{{pascalCase name}}Schema = z.object({
{{#each fields}}
{{#unless isGenerated}}
  {{name}}: {{zodType type}}{{#unless required}}.optional(){{/unless}},
{{/unless}}
{{/each}}
})

const update{{pascalCase name}}Schema = create{{pascalCase name}}Schema.partial()

const {{camelCase name}}ListSchema = z.object({
  page: z.number().int().positive().default(1),
  limit: z.number().int().positive().max(100).default(10),
  sort: z.enum([{{#each sortableFields}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}]).optional(),
  order: z.enum(['asc', 'desc']).default('asc'),
  search: z.string().optional(),
{{#each filterableFields}}
  {{name}}: {{zodType type}}.optional(),
{{/each}}
})

/**
 * {{pascalCase name}} tRPC router
 */
export const {{camelCase name}}Router = router({
  /**
   * Get all {{pluralize (lowerCase name)}}
   */
  list: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input({{camelCase name}}ListSchema)
    .query(async ({ input }) => {
      const { page, limit, sort, order, ...filters } = input

      const result = await service.findAll({
        page,
        limit,
        sort,
        order,
        filters,
      })

      return {
        items: result.data,
        meta: {
          total: result.total,
          page: result.page,
          limit: result.limit,
          totalPages: result.totalPages,
        },
      }
    }),

  /**
   * Get {{lowerCase name}} by ID
   */
  byId: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input({{camelCase name}}IdSchema)
    .query(async ({ input }) => {
      const result = await service.findById(input.id)

      if (!result) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: '{{pascalCase name}} not found',
        })
      }

      return result
    }),

  /**
   * Create new {{lowerCase name}}
   */
  create: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input(create{{pascalCase name}}Schema)
    .mutation(async ({ input{{#if auth}}, ctx{{/if}} }) => {
      {{#if auth}}
      // Access authenticated user via ctx.user
      {{/if}}
      return service.create(input)
    }),

  /**
   * Update {{lowerCase name}}
   */
  update: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input(
      z.object({
        id: z.string().uuid(),
        data: update{{pascalCase name}}Schema,
      })
    )
    .mutation(async ({ input }) => {
      const result = await service.update(input.id, input.data)

      if (!result) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: '{{pascalCase name}} not found',
        })
      }

      return result
    }),

  /**
   * Delete {{lowerCase name}}
   */
  delete: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input({{camelCase name}}IdSchema)
    .mutation(async ({ input }) => {
      const deleted = await service.delete(input.id)

      if (!deleted) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: '{{pascalCase name}} not found',
        })
      }

      return { success: true }
    }),

  /**
   * Batch delete {{pluralize (lowerCase name)}}
   */
  deleteMany: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input(z.object({ ids: z.array(z.string().uuid()) }))
    .mutation(async ({ input }) => {
      const count = await service.deleteMany(input.ids)
      return { deleted: count }
    }),

  /**
   * Check if {{lowerCase name}} exists
   */
  exists: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input({{camelCase name}}IdSchema)
    .query(async ({ input }) => {
      const result = await service.findById(input.id)
      return { exists: !!result }
    }),

  /**
   * Count {{pluralize (lowerCase name)}}
   */
  count: {{#if auth}}protectedProcedure{{else}}publicProcedure{{/if}}
    .input({{camelCase name}}ListSchema.pick({ search: true{{#each filterableFields}}, {{name}}: true{{/each}} }))
    .query(async ({ input }) => {
      const count = await service.count(input)
      return { count }
    }),
})

/**
 * Export type for client
 */
export type {{pascalCase name}}Router = typeof {{camelCase name}}Router
