/**
 * Mock code generator for the playground
 * In a real implementation, this would use the actual OpenGenerator core
 */

interface GeneratorConfig {
  api: 'rest' | 'graphql' | 'trpc'
  adapter: 'express' | 'fastify' | 'hono' | 'koa'
  database: 'prisma' | 'drizzle' | 'kysely'
  validation: boolean
  tests: boolean
}

interface ParsedModel {
  name: string
  fields: Array<{
    name: string
    type: string
    isRequired: boolean
    isId: boolean
    isRelation: boolean
  }>
}

function parseSchema(schema: string): ParsedModel[] {
  const models: ParsedModel[] = []
  const modelRegex = /model\s+(\w+)\s*\{([^}]+)\}/g

  let match
  while ((match = modelRegex.exec(schema)) !== null) {
    const name = match[1]
    const body = match[2]
    const fields: ParsedModel['fields'] = []

    const fieldRegex = /(\w+)\s+(\w+)(\[\])?\s*(\?)?/g
    let fieldMatch
    while ((fieldMatch = fieldRegex.exec(body)) !== null) {
      const [, fieldName, fieldType, isArray, isOptional] = fieldMatch
      if (!fieldName.startsWith('@')) {
        fields.push({
          name: fieldName,
          type: isArray ? `${fieldType}[]` : fieldType,
          isRequired: !isOptional,
          isId: body.includes(`@id`) && fieldName === 'id',
          isRelation: fieldType.match(/^[A-Z]/) !== null,
        })
      }
    }

    models.push({ name, fields })
  }

  return models
}

export async function generateCode(
  schema: string,
  config: GeneratorConfig
): Promise<Record<string, string>> {
  // Simulate async generation
  await new Promise((resolve) => setTimeout(resolve, 500))

  const models = parseSchema(schema)
  const output: Record<string, string> = {}

  for (const model of models) {
    const modelName = model.name
    const modelNameLower = modelName.toLowerCase()

    // Generate types
    output[`${modelNameLower}.types.ts`] = generateTypes(model)

    // Generate based on API style
    if (config.api === 'rest') {
      output[`${modelNameLower}.router.ts`] = generateRestRouter(model, config)
      output[`${modelNameLower}.controller.ts`] = generateController(model)
      output[`${modelNameLower}.service.ts`] = generateService(model, config)
    } else if (config.api === 'graphql') {
      output[`${modelNameLower}.schema.graphql`] = generateGraphQLSchema(model)
      output[`${modelNameLower}.resolvers.ts`] = generateResolvers(model)
    } else if (config.api === 'trpc') {
      output[`${modelNameLower}.router.ts`] = generateTrpcRouter(model)
    }

    // Generate validation schemas if enabled
    if (config.validation) {
      output[`${modelNameLower}.schema.ts`] = generateValidationSchema(model)
    }

    // Generate tests if enabled
    if (config.tests) {
      output[`${modelNameLower}.test.ts`] = generateTests(model, config)
    }
  }

  return output
}

function generateTypes(model: ParsedModel): string {
  const fields = model.fields
    .filter((f) => !f.isRelation)
    .map((f) => {
      const tsType = mapToTsType(f.type)
      return `  ${f.name}${f.isRequired ? '' : '?'}: ${tsType}`
    })
    .join('\n')

  return `/**
 * ${model.name} Types
 * Generated by OpenGenerator
 */

export interface ${model.name} {
${fields}
  createdAt: Date
  updatedAt: Date
}

export interface Create${model.name}Input {
${model.fields
  .filter((f) => !f.isId && !f.isRelation && f.name !== 'createdAt' && f.name !== 'updatedAt')
  .map((f) => `  ${f.name}${f.isRequired ? '' : '?'}: ${mapToTsType(f.type)}`)
  .join('\n')}
}

export interface Update${model.name}Input {
${model.fields
  .filter((f) => !f.isId && !f.isRelation && f.name !== 'createdAt' && f.name !== 'updatedAt')
  .map((f) => `  ${f.name}?: ${mapToTsType(f.type)}`)
  .join('\n')}
}
`
}

function generateRestRouter(model: ParsedModel, config: GeneratorConfig): string {
  const name = model.name
  const nameLower = name.toLowerCase()

  return `/**
 * ${name} Router
 * Generated by OpenGenerator
 */

import { Router } from '${config.adapter}'
import { ${name}Controller } from './${nameLower}.controller'
import { ${name}Service } from './${nameLower}.service'
${config.validation ? `import { ${nameLower}Schema } from './${nameLower}.schema'\nimport { validate } from '../middleware/validate'` : ''}

const router = Router()
const service = new ${name}Service()
const controller = new ${name}Controller(service)

// GET /${nameLower}s - List all
router.get('/', controller.findAll.bind(controller))

// GET /${nameLower}s/:id - Get by ID
router.get('/:id', controller.findById.bind(controller))

// POST /${nameLower}s - Create
router.post(
  '/',
  ${config.validation ? `validate(${nameLower}Schema.create),` : ''}
  controller.create.bind(controller)
)

// PUT /${nameLower}s/:id - Update
router.put(
  '/:id',
  ${config.validation ? `validate(${nameLower}Schema.update),` : ''}
  controller.update.bind(controller)
)

// DELETE /${nameLower}s/:id - Delete
router.delete('/:id', controller.delete.bind(controller))

export { router as ${nameLower}Router }
`
}

function generateController(model: ParsedModel): string {
  const name = model.name

  return `/**
 * ${name} Controller
 * Generated by OpenGenerator
 */

import type { Request, Response, NextFunction } from 'express'
import type { ${name}Service } from './${name.toLowerCase()}.service'

export class ${name}Controller {
  constructor(private readonly service: ${name}Service) {}

  async findAll(req: Request, res: Response, next: NextFunction) {
    try {
      const result = await this.service.findAll(req.query)
      res.json({ data: result.data, meta: result.meta })
    } catch (error) {
      next(error)
    }
  }

  async findById(req: Request, res: Response, next: NextFunction) {
    try {
      const result = await this.service.findById(req.params.id)
      if (!result) {
        return res.status(404).json({ error: '${name} not found' })
      }
      res.json({ data: result })
    } catch (error) {
      next(error)
    }
  }

  async create(req: Request, res: Response, next: NextFunction) {
    try {
      const result = await this.service.create(req.body)
      res.status(201).json({ data: result })
    } catch (error) {
      next(error)
    }
  }

  async update(req: Request, res: Response, next: NextFunction) {
    try {
      const result = await this.service.update(req.params.id, req.body)
      if (!result) {
        return res.status(404).json({ error: '${name} not found' })
      }
      res.json({ data: result })
    } catch (error) {
      next(error)
    }
  }

  async delete(req: Request, res: Response, next: NextFunction) {
    try {
      const deleted = await this.service.delete(req.params.id)
      if (!deleted) {
        return res.status(404).json({ error: '${name} not found' })
      }
      res.status(204).send()
    } catch (error) {
      next(error)
    }
  }
}
`
}

function generateService(model: ParsedModel, _config: GeneratorConfig): string {
  const name = model.name
  const nameLower = name.toLowerCase()

  return `/**
 * ${name} Service
 * Generated by OpenGenerator
 */

import { ${nameLower}Repository } from './${nameLower}.repository'
import type { Create${name}Input, Update${name}Input } from './${nameLower}.types'

export class ${name}Service {
  private readonly repository = new ${nameLower}Repository()

  async findAll(query: Record<string, unknown>) {
    const { page = 1, limit = 10, ...filters } = query
    const [data, total] = await Promise.all([
      this.repository.findMany({
        skip: (Number(page) - 1) * Number(limit),
        take: Number(limit),
        where: filters,
      }),
      this.repository.count({ where: filters }),
    ])

    return {
      data,
      meta: {
        total,
        page: Number(page),
        limit: Number(limit),
        totalPages: Math.ceil(total / Number(limit)),
      },
    }
  }

  async findById(id: string) {
    return this.repository.findUnique({ where: { id } })
  }

  async create(input: Create${name}Input) {
    return this.repository.create({ data: input })
  }

  async update(id: string, input: Update${name}Input) {
    const existing = await this.findById(id)
    if (!existing) return null
    return this.repository.update({ where: { id }, data: input })
  }

  async delete(id: string) {
    const existing = await this.findById(id)
    if (!existing) return false
    await this.repository.delete({ where: { id } })
    return true
  }
}
`
}

function generateValidationSchema(model: ParsedModel): string {
  const name = model.name
  const nameLower = name.toLowerCase()

  const fields = model.fields
    .filter((f) => !f.isId && !f.isRelation && f.name !== 'createdAt' && f.name !== 'updatedAt')
    .map((f) => {
      const zodType = mapToZodType(f.type)
      return `  ${f.name}: ${zodType}${f.isRequired ? '' : '.optional()'}`
    })
    .join(',\n')

  return `/**
 * ${name} Validation Schema
 * Generated by OpenGenerator
 */

import { z } from 'zod'

export const create${name}Schema = z.object({
${fields}
})

export const update${name}Schema = create${name}Schema.partial()

export const ${nameLower}IdSchema = z.object({
  id: z.string().uuid()
})

export const ${nameLower}Schema = {
  create: create${name}Schema,
  update: update${name}Schema,
  id: ${nameLower}IdSchema,
}
`
}

function generateGraphQLSchema(model: ParsedModel): string {
  const name = model.name

  const fields = model.fields
    .filter((f) => !f.isRelation)
    .map((f) => `  ${f.name}: ${mapToGraphQLType(f.type)}${f.isRequired ? '!' : ''}`)
    .join('\n')

  const inputFields = model.fields
    .filter((f) => !f.isId && !f.isRelation && f.name !== 'createdAt' && f.name !== 'updatedAt')
    .map((f) => `  ${f.name}: ${mapToGraphQLType(f.type)}${f.isRequired ? '!' : ''}`)
    .join('\n')

  return `# ${name} GraphQL Schema
# Generated by OpenGenerator

type ${name} {
${fields}
  createdAt: DateTime!
  updatedAt: DateTime!
}

input Create${name}Input {
${inputFields}
}

input Update${name}Input {
${model.fields
  .filter((f) => !f.isId && !f.isRelation)
  .map((f) => `  ${f.name}: ${mapToGraphQLType(f.type)}`)
  .join('\n')}
}

extend type Query {
  ${name.toLowerCase()}(id: ID!): ${name}
  ${name.toLowerCase()}s(limit: Int, offset: Int): [${name}!]!
}

extend type Mutation {
  create${name}(input: Create${name}Input!): ${name}!
  update${name}(id: ID!, input: Update${name}Input!): ${name}
  delete${name}(id: ID!): Boolean!
}
`
}

function generateResolvers(model: ParsedModel): string {
  const name = model.name
  const nameLower = name.toLowerCase()

  return `/**
 * ${name} Resolvers
 * Generated by OpenGenerator
 */

import { ${name}Service } from './${nameLower}.service'

const service = new ${name}Service()

export const ${nameLower}Resolvers = {
  Query: {
    ${nameLower}: (_: unknown, { id }: { id: string }) => service.findById(id),
    ${nameLower}s: (_: unknown, args: { limit?: number; offset?: number }) =>
      service.findAll({ limit: args.limit, page: args.offset ? args.offset / (args.limit || 10) + 1 : 1 }),
  },

  Mutation: {
    create${name}: (_: unknown, { input }: { input: unknown }) => service.create(input as any),
    update${name}: (_: unknown, { id, input }: { id: string; input: unknown }) =>
      service.update(id, input as any),
    delete${name}: async (_: unknown, { id }: { id: string }) => {
      return service.delete(id)
    },
  },
}
`
}

function generateTrpcRouter(model: ParsedModel): string {
  const name = model.name
  const nameLower = name.toLowerCase()

  return `/**
 * ${name} tRPC Router
 * Generated by OpenGenerator
 */

import { z } from 'zod'
import { router, publicProcedure } from '../trpc'
import { ${name}Service } from './${nameLower}.service'

const service = new ${name}Service()

export const ${nameLower}Router = router({
  list: publicProcedure
    .input(z.object({
      page: z.number().default(1),
      limit: z.number().default(10),
    }))
    .query(({ input }) => service.findAll(input)),

  byId: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(({ input }) => service.findById(input.id)),

  create: publicProcedure
    .input(z.object({
${model.fields
  .filter((f) => !f.isId && !f.isRelation && f.name !== 'createdAt' && f.name !== 'updatedAt')
  .map((f) => `      ${f.name}: ${mapToZodType(f.type)}${f.isRequired ? '' : '.optional()'}`)
  .join(',\n')}
    }))
    .mutation(({ input }) => service.create(input)),

  update: publicProcedure
    .input(z.object({
      id: z.string().uuid(),
      data: z.object({
${model.fields
  .filter((f) => !f.isId && !f.isRelation)
  .map((f) => `        ${f.name}: ${mapToZodType(f.type)}.optional()`)
  .join(',\n')}
      })
    }))
    .mutation(({ input }) => service.update(input.id, input.data)),

  delete: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(({ input }) => service.delete(input.id)),
})
`
}

function generateTests(model: ParsedModel, _config: GeneratorConfig): string {
  const name = model.name
  const nameLower = name.toLowerCase()

  return `/**
 * ${name} Tests
 * Generated by OpenGenerator
 */

import { describe, it, expect, beforeEach, vi } from 'vitest'
import { ${name}Service } from './${nameLower}.service'

describe('${name}Service', () => {
  let service: ${name}Service

  beforeEach(() => {
    service = new ${name}Service()
    vi.clearAllMocks()
  })

  describe('findAll', () => {
    it('should return paginated results', async () => {
      const result = await service.findAll({ page: 1, limit: 10 })
      expect(result.data).toBeDefined()
      expect(result.meta).toBeDefined()
    })
  })

  describe('findById', () => {
    it('should return null for non-existent id', async () => {
      const result = await service.findById('non-existent')
      expect(result).toBeNull()
    })
  })

  describe('create', () => {
    it('should create new ${nameLower}', async () => {
      const input = {
${model.fields
  .filter((f) => !f.isId && !f.isRelation && f.name !== 'createdAt' && f.name !== 'updatedAt' && f.isRequired)
  .map((f) => `        ${f.name}: ${getMockValue(f.type)}`)
  .join(',\n')}
      }
      const result = await service.create(input)
      expect(result).toBeDefined()
    })
  })
})
`
}

function mapToTsType(prismaType: string): string {
  const typeMap: Record<string, string> = {
    String: 'string',
    Int: 'number',
    Float: 'number',
    Boolean: 'boolean',
    DateTime: 'Date',
    Json: 'Record<string, unknown>',
    Decimal: 'number',
  }
  return typeMap[prismaType] || 'unknown'
}

function mapToZodType(prismaType: string): string {
  const typeMap: Record<string, string> = {
    String: 'z.string()',
    Int: 'z.number().int()',
    Float: 'z.number()',
    Boolean: 'z.boolean()',
    DateTime: 'z.date()',
    Json: 'z.record(z.unknown())',
    Decimal: 'z.number()',
  }
  return typeMap[prismaType] || 'z.unknown()'
}

function mapToGraphQLType(prismaType: string): string {
  const typeMap: Record<string, string> = {
    String: 'String',
    Int: 'Int',
    Float: 'Float',
    Boolean: 'Boolean',
    DateTime: 'DateTime',
    Json: 'JSON',
    Decimal: 'Float',
  }
  return typeMap[prismaType] || 'String'
}

function getMockValue(prismaType: string): string {
  const mockMap: Record<string, string> = {
    String: "'test'",
    Int: '1',
    Float: '1.0',
    Boolean: 'true',
    DateTime: 'new Date()',
  }
  return mockMap[prismaType] || 'null'
}
